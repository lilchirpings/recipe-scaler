<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smart Recipe Scaler</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-900 text-gray-100">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect } = React;

        // Unit conversion maps
        const VOLUME_CONVERSIONS = {
            // To teaspoons
            'tsp': 1,
            'teaspoon': 1,
            'teaspoons': 1,
            'tbsp': 3,
            'tablespoon': 3,
            'tablespoons': 3,
            'floz': 6,
            'fl oz': 6,
            'fluid ounce': 6,
            'fluid ounces': 6,
            'cup': 48,
            'cups': 48,
            'c': 48,
            'pint': 96,
            'pints': 96,
            'pt': 96,
            'quart': 192,
            'quarts': 192,
            'qt': 192,
            'gallon': 768,
            'gallons': 768,
            'gal': 768,
            // Metric
            'ml': 0.202884,
            'milliliter': 0.202884,
            'milliliters': 0.202884,
            'l': 202.884,
            'liter': 202.884,
            'liters': 202.884,
        };

        const WEIGHT_CONVERSIONS = {
            // To grams
            'g': 1,
            'gram': 1,
            'grams': 1,
            'kg': 1000,
            'kilogram': 1000,
            'kilograms': 1000,
            'oz': 28.3495,
            'ounce': 28.3495,
            'ounces': 28.3495,
            'lb': 453.592,
            'lbs': 453.592,
            'pound': 453.592,
            'pounds': 453.592,
        };

        // Smart unit conversion for display
        const smartConvertVolume = (tsp, useMetric) => {
            if (useMetric) {
                const ml = tsp / 0.202884;
                if (ml >= 1000) return { value: ml / 1000, unit: 'L' };
                return { value: ml, unit: 'ml' };
            } else {
                if (tsp >= 768) return { value: tsp / 768, unit: 'gal' };
                if (tsp >= 192) return { value: tsp / 192, unit: 'qt' };
                if (tsp >= 96) return { value: tsp / 96, unit: 'pt' };
                if (tsp >= 48) return { value: tsp / 48, unit: 'cup' };
                if (tsp >= 6) return { value: tsp / 6, unit: 'fl oz' };
                if (tsp >= 3) return { value: tsp / 3, unit: 'tbsp' };
                return { value: tsp, unit: 'tsp' };
            }
        };

        const smartConvertWeight = (g, useMetric) => {
            if (useMetric) {
                if (g >= 1000) return { value: g / 1000, unit: 'kg' };
                return { value: g, unit: 'g' };
            } else {
                if (g >= 453.592) return { value: g / 453.592, unit: 'lb' };
                return { value: g / 28.3495, unit: 'oz' };
            }
        };

        // Parse ingredient line
        const parseIngredient = (line, rangeMode = 'average') => {
            line = line.trim();
            if (!line) return null;

            // Remove common prefixes
            line = line.replace(/^[-‚Ä¢*]\s*/, '');
            
            // Try to match: quantity unit ingredient
            // Supports: "2 cups flour", "1/2 cup sugar", "2 1/2 cups water", "2-1/2 cups" (mixed fraction), "1.5 tsp salt", "2-3 cups water", "3 eggs"
            const patterns = [
                // Mixed fraction with unit: "2 1/2 cups"
                /^(\d+)\s+(\d+\/\d+)\s+([a-zA-Z]+)\s+(.+)$/,
                // Ambiguous: could be range or mixed fraction: "2-1/2 cups" or "1-2 cups"
                /^(\d+)\s*-\s*(\d+\/\d+|\d+)\s+([a-zA-Z]+)\s+(.+)$/,
                // Range with mixed fractions: "1 1/2-2 cups" or "2-2 1/2 cups"
                /^(\d+)\s+(\d+\/\d+)\s*-\s*(\d+)\s+(\d+\/\d+)\s+([a-zA-Z]+)\s+(.+)$/,
                /^(\d+)\s*-\s*(\d+)\s+(\d+\/\d+)\s+([a-zA-Z]+)\s+(.+)$/,
                /^(\d+)\s+(\d+\/\d+)\s*-\s*(\d+)\s+([a-zA-Z]+)\s+(.+)$/,
                // Fraction or decimal with unit (with range support)
                /^(\d+\/\d+|\d+\.\d+)\s*-\s*(\d+\/\d+|\d+\.\d+)\s*([a-zA-Z]+)\s+(.+)$/,
                // Just number with unit
                /^(\d+)\s+([a-zA-Z]+)\s+(.+)$/,
                // Unicode fraction with unit
                /^([¬Ω‚Öì‚Öî¬º¬æ‚Öõ‚Öú‚Öù‚Öû])\s*([a-zA-Z]+)\s+(.+)$/,
                // Mixed fraction count: "2 1/2 eggs"
                /^(\d+)\s+(\d+\/\d+)\s+(.+)$/,
                // Ambiguous count: "2-1/2 eggs" or "2-3 eggs"
                /^(\d+)\s*-\s*(\d+\/\d+|\d+)\s+(.+)$/,
                // Count with range: "2-3 eggs"
                /^(\d+\/\d+|\d+\.\d+)\s*-\s*(\d+\/\d+|\d+\.\d+)\s+(.+)$/,
                // Unicode fraction count only
                /^([¬Ω‚Öì‚Öî¬º¬æ‚Öõ‚Öú‚Öù‚Öû])\s+(.+)$/,
            ];

            for (const pattern of patterns) {
                const match = line.match(pattern);
                if (match) {
                    let quantity, unit, ingredient, isRange = false, rangeOriginal = null;
                    
                    // Handle mixed fractions with unit: "2 1/2 cups flour"
                    if (pattern === patterns[0]) {
                        const whole = parseInt(match[1]);
                        const frac = parseQuantity(match[2]);
                        quantity = whole + frac;
                        unit = match[3].toLowerCase();
                        ingredient = match[4];
                    }
                    // Handle ambiguous "2-1/2" format with unit - could be range or mixed fraction
                    else if (pattern === patterns[1]) {
                        const q1 = parseInt(match[1]);
                        const q2 = parseQuantity(match[2]);
                        
                        // If q1 > q2, treat as mixed fraction (e.g., "2-1/2" = 2.5)
                        // If q1 < q2, treat as range (e.g., "1-2" = range from 1 to 2)
                        if (q1 > q2) {
                            // Mixed fraction: "2-1/2 cups" = 2.5 cups
                            quantity = q1 + q2;
                            unit = match[3].toLowerCase();
                            ingredient = match[4];
                        } else {
                            // Valid range: "1-2 cups"
                            isRange = true;
                            rangeOriginal = `${match[1]}-${match[2]}`;
                            quantity = rangeMode === 'low' ? q1 : rangeMode === 'high' ? q2 : (q1 + q2) / 2;
                            unit = match[3].toLowerCase();
                            ingredient = match[4];
                        }
                    }
                    // Handle mixed fraction ranges with unit
                    else if (pattern === patterns[2] || pattern === patterns[3] || pattern === patterns[4]) {
                        isRange = true;
                        let q1, q2;
                        if (pattern === patterns[2]) {
                            // "1 1/2-2 1/2 cups"
                            q1 = parseInt(match[1]) + parseQuantity(match[2]);
                            q2 = parseInt(match[3]) + parseQuantity(match[4]);
                            rangeOriginal = `${match[1]} ${match[2]}-${match[3]} ${match[4]}`;
                            unit = match[5].toLowerCase();
                            ingredient = match[6];
                        } else if (pattern === patterns[3]) {
                            // "2-2 1/2 cups"
                            q1 = parseInt(match[1]);
                            q2 = parseInt(match[2]) + parseQuantity(match[3]);
                            rangeOriginal = `${match[1]}-${match[2]} ${match[3]}`;
                            unit = match[4].toLowerCase();
                            ingredient = match[5];
                        } else {
                            // "2 1/2-3 cups"
                            q1 = parseInt(match[1]) + parseQuantity(match[2]);
                            q2 = parseInt(match[3]);
                            rangeOriginal = `${match[1]} ${match[2]}-${match[3]}`;
                            unit = match[4].toLowerCase();
                            ingredient = match[5];
                        }
                        quantity = rangeMode === 'low' ? q1 : rangeMode === 'high' ? q2 : (q1 + q2) / 2;
                    }
                    // Fraction/decimal range: "1/2-3/4 cups"
                    else if (pattern === patterns[5]) {
                        const q1 = parseQuantity(match[1]);
                        const q2 = parseQuantity(match[2]);
                        isRange = true;
                        rangeOriginal = `${match[1]}-${match[2]}`;
                        quantity = rangeMode === 'low' ? q1 : rangeMode === 'high' ? q2 : (q1 + q2) / 2;
                        unit = match[3].toLowerCase();
                        ingredient = match[4];
                    }
                    // Mixed fraction count: "2 1/2 eggs"
                    else if (pattern === patterns[8]) {
                        const whole = parseInt(match[1]);
                        const frac = parseQuantity(match[2]);
                        quantity = whole + frac;
                        ingredient = match[3];
                        
                        return {
                            original: line,
                            quantity,
                            unit: 'count',
                            ingredient: ingredient.trim(),
                            type: 'count',
                            baseValue: quantity,
                            isRange,
                            rangeOriginal
                        };
                    }
                    // Handle ambiguous "2-1/2" format for count - could be range or mixed fraction
                    else if (pattern === patterns[9]) {
                        const q1 = parseInt(match[1]);
                        const q2 = parseQuantity(match[2]);
                        
                        // If q1 > q2, treat as mixed fraction (e.g., "2-1/2" = 2.5)
                        // If q1 < q2, treat as range (e.g., "1-2" = range from 1 to 2)
                        if (q1 > q2) {
                            // Mixed fraction: "2-1/2 eggs" = 2.5 eggs
                            quantity = q1 + q2;
                            ingredient = match[3];
                        } else {
                            // Valid range: "1-2 eggs"
                            isRange = true;
                            rangeOriginal = `${match[1]}-${match[2]}`;
                            quantity = rangeMode === 'low' ? q1 : rangeMode === 'high' ? q2 : (q1 + q2) / 2;
                            ingredient = match[3];
                        }
                        
                        return {
                            original: line,
                            quantity,
                            unit: 'count',
                            ingredient: ingredient.trim(),
                            type: 'count',
                            baseValue: quantity,
                            isRange,
                            rangeOriginal
                        };
                    }
                    // Fraction/decimal range for count
                    else if (pattern === patterns[10]) {
                        const q1 = parseQuantity(match[1]);
                        const q2 = parseQuantity(match[2]);
                        isRange = true;
                        rangeOriginal = `${match[1]}-${match[2]}`;
                        quantity = rangeMode === 'low' ? q1 : rangeMode === 'high' ? q2 : (q1 + q2) / 2;
                        ingredient = match[3];
                        
                        return {
                            original: line,
                            quantity,
                            unit: 'count',
                            ingredient: ingredient.trim(),
                            type: 'count',
                            baseValue: quantity,
                            isRange,
                            rangeOriginal
                        };
                    }
                    // Unicode fraction count: "¬Ω onion"
                    else if (pattern === patterns[11]) {
                        quantity = parseUnicodeFraction(match[1]);
                        ingredient = match[2];
                        
                        return {
                            original: line,
                            quantity,
                            unit: 'count',
                            ingredient: ingredient.trim(),
                            type: 'count',
                            baseValue: quantity,
                            isRange,
                            rangeOriginal
                        };
                    }
                    // Simple unit-based
                    else if (pattern === patterns[6]) {
                        quantity = parseQuantity(match[1]);
                        unit = match[2].toLowerCase();
                        ingredient = match[3];
                    }
                    // Unicode fraction with unit
                    else if (pattern === patterns[7]) {
                        quantity = parseUnicodeFraction(match[1]);
                        unit = match[2].toLowerCase();
                        ingredient = match[3];
                    }

                    // Determine if volume or weight
                    let type = null;
                    let baseValue = null;

                    if (VOLUME_CONVERSIONS[unit]) {
                        type = 'volume';
                        baseValue = quantity * VOLUME_CONVERSIONS[unit];
                    } else if (WEIGHT_CONVERSIONS[unit]) {
                        type = 'weight';
                        baseValue = quantity * WEIGHT_CONVERSIONS[unit];
                    }

                    if (type) {
                        return {
                            original: line,
                            quantity,
                            unit,
                            ingredient: ingredient.trim(),
                            type,
                            baseValue,
                            isRange,
                            rangeOriginal
                        };
                    }
                }
            }

            return null; // Couldn't parse
        };

        const parseQuantity = (str) => {
            // Handle fractions like "1/2"
            if (str.includes('/')) {
                const [num, denom] = str.split('/').map(Number);
                return num / denom;
            }
            return parseFloat(str);
        };

        const parseUnicodeFraction = (str) => {
            const fractions = {
                '¬Ω': 0.5, '‚Öì': 0.333, '‚Öî': 0.667,
                '¬º': 0.25, '¬æ': 0.75,
                '‚Öõ': 0.125, '‚Öú': 0.375, '‚Öù': 0.625, '‚Öû': 0.875
            };
            return fractions[str] || 1;
        };

        const formatNumber = (num) => {
            if (num % 1 === 0) return num.toString();
            
            // Try to convert to fraction if close
            const fractions = [
                [0.125, '‚Öõ'], [0.25, '¬º'], [0.333, '‚Öì'], [0.375, '‚Öú'],
                [0.5, '¬Ω'], [0.625, '‚Öù'], [0.667, '‚Öî'], [0.75, '¬æ'], [0.875, '‚Öû']
            ];
            
            const decimal = num % 1;
            const whole = Math.floor(num);
            
            for (const [val, frac] of fractions) {
                if (Math.abs(decimal - val) < 0.01) {
                    return whole > 0 ? `${whole} ${frac}` : frac;
                }
            }
            
            return num.toFixed(2).replace(/\.?0+$/, '');
        };

        function RecipeScaler() {
            const [inputText, setInputText] = useState('');
            const [originalServings, setOriginalServings] = useState(4);
            const [targetServings, setTargetServings] = useState(8);
            const [useMetric, setUseMetric] = useState(false);
            const [parsedIngredients, setParsedIngredients] = useState([]);
            const [savedRecipes, setSavedRecipes] = useState([]);
            const [recipeName, setRecipeName] = useState('');
            const [showSaved, setShowSaved] = useState(false);
            const [rangeHandling, setRangeHandling] = useState('average'); // 'low', 'average', 'high'
            const [copySuccess, setCopySuccess] = useState(false);

            // Load saved recipes from localStorage
            useEffect(() => {
                const saved = localStorage.getItem('savedRecipes');
                if (saved) {
                    setSavedRecipes(JSON.parse(saved));
                }
            }, []);

            const parseInput = () => {
                const lines = inputText.split('\n');
                const ingredients = [];
                
                for (const line of lines) {
                    const parsed = parseIngredient(line, rangeHandling);
                    if (parsed) {
                        ingredients.push(parsed);
                    }
                }
                
                setParsedIngredients(ingredients);
            };

            const scaleIngredient = (ingredient) => {
                const scaleFactor = targetServings / originalServings;
                const scaledBaseValue = ingredient.baseValue * scaleFactor;
                
                if (ingredient.type === 'volume') {
                    return smartConvertVolume(scaledBaseValue, useMetric);
                } else if (ingredient.type === 'weight') {
                    return smartConvertWeight(scaledBaseValue, useMetric);
                } else if (ingredient.type === 'count') {
                    // For count items, just scale the number
                    return { value: scaledBaseValue, unit: '' };
                }
            };

            const copyToClipboard = () => {
                if (parsedIngredients.length === 0) return;
                
                let text = `Recipe (${targetServings} servings)\n\n`;
                parsedIngredients.forEach(ingredient => {
                    const scaled = scaleIngredient(ingredient);
                    const amount = `${formatNumber(scaled.value)}${scaled.unit ? ' ' + scaled.unit : ''}`;
                    text += `${amount} ${ingredient.ingredient}\n`;
                });
                
                navigator.clipboard.writeText(text).then(() => {
                    setCopySuccess(true);
                    setTimeout(() => setCopySuccess(false), 2000);
                }).catch(err => {
                    console.error('Failed to copy:', err);
                });
            };

            const saveRecipe = () => {
                if (!recipeName.trim()) {
                    alert('Please enter a recipe name');
                    return;
                }
                
                const recipe = {
                    id: Date.now(),
                    name: recipeName,
                    servings: originalServings,
                    ingredients: inputText,
                    date: new Date().toISOString()
                };
                
                const updated = [...savedRecipes, recipe];
                setSavedRecipes(updated);
                localStorage.setItem('savedRecipes', JSON.stringify(updated));
                setRecipeName('');
                alert('Recipe saved!');
            };

            const loadRecipe = (recipe) => {
                setInputText(recipe.ingredients);
                setOriginalServings(recipe.servings);
                setTargetServings(recipe.servings);
                setShowSaved(false);
                parseInput();
            };

            const deleteRecipe = (id) => {
                const updated = savedRecipes.filter(r => r.id !== id);
                setSavedRecipes(updated);
                localStorage.setItem('savedRecipes', JSON.stringify(updated));
            };

            useEffect(() => {
                if (inputText) {
                    parseInput();
                }
            }, [inputText, rangeHandling]);

            return (
                <div className="min-h-screen bg-gray-900 p-4">
                    <div className="max-w-6xl mx-auto">
                        <div className="bg-gray-800 rounded-lg shadow-xl p-6 mb-6">
                            <h1 className="text-3xl font-bold text-green-400 mb-2">Smart Recipe Scaler</h1>
                            <p className="text-gray-400">Paste ingredients, scale servings, get smart unit conversions</p>
                        </div>

                        <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
                            {/* Input Section */}
                            <div className="bg-gray-800 rounded-lg shadow-xl p-6">
                                <div className="flex justify-between items-center mb-4">
                                    <h2 className="text-xl font-bold text-green-400">Input</h2>
                                    <button
                                        onClick={() => setShowSaved(!showSaved)}
                                        className="px-3 py-1 bg-blue-600 hover:bg-blue-700 rounded text-sm"
                                    >
                                        {showSaved ? 'Hide' : 'Saved Recipes'}
                                    </button>
                                </div>

                                {showSaved && (
                                    <div className="mb-4 p-4 bg-gray-700 rounded max-h-64 overflow-y-auto">
                                        {savedRecipes.length === 0 ? (
                                            <p className="text-gray-400">No saved recipes</p>
                                        ) : (
                                            savedRecipes.map(recipe => (
                                                <div key={recipe.id} className="mb-2 p-2 bg-gray-600 rounded flex justify-between items-center">
                                                    <div>
                                                        <div className="font-bold">{recipe.name}</div>
                                                        <div className="text-sm text-gray-400">{recipe.servings} servings</div>
                                                    </div>
                                                    <div className="flex gap-2">
                                                        <button
                                                            onClick={() => loadRecipe(recipe)}
                                                            className="px-2 py-1 bg-green-600 hover:bg-green-700 rounded text-sm"
                                                        >
                                                            Load
                                                        </button>
                                                        <button
                                                            onClick={() => deleteRecipe(recipe.id)}
                                                            className="px-2 py-1 bg-red-600 hover:bg-red-700 rounded text-sm"
                                                        >
                                                            Delete
                                                        </button>
                                                    </div>
                                                </div>
                                            ))
                                        )}
                                    </div>
                                )}

                                <textarea
                                    value={inputText}
                                    onChange={(e) => setInputText(e.target.value)}
                                    placeholder="Paste ingredients here... (e.g., 2 cups flour, 1/2 tsp salt, 250g sugar)"
                                    className="w-full h-64 bg-gray-700 text-gray-100 p-3 rounded border border-gray-600 focus:border-green-400 focus:outline-none font-mono text-sm"
                                />

                                <div className="mt-4 grid grid-cols-2 gap-4">
                                    <div>
                                        <label className="block text-sm text-gray-400 mb-1">Original Servings</label>
                                        <input
                                            type="number"
                                            value={originalServings}
                                            onChange={(e) => setOriginalServings(Number(e.target.value))}
                                            min="1"
                                            className="w-full bg-gray-700 text-gray-100 p-2 rounded border border-gray-600 focus:border-green-400 focus:outline-none"
                                        />
                                    </div>
                                    <div>
                                        <label className="block text-sm text-gray-400 mb-1">Target Servings</label>
                                        <input
                                            type="number"
                                            value={targetServings}
                                            onChange={(e) => setTargetServings(Number(e.target.value))}
                                            min="1"
                                            className="w-full bg-gray-700 text-gray-100 p-2 rounded border border-gray-600 focus:border-green-400 focus:outline-none"
                                        />
                                    </div>
                                </div>

                                <div className="mt-4 flex items-center justify-between">
                                    <label className="flex items-center cursor-pointer">
                                        <input
                                            type="checkbox"
                                            checked={useMetric}
                                            onChange={(e) => setUseMetric(e.target.checked)}
                                            className="mr-2"
                                        />
                                        <span className="text-sm text-gray-400">Use Metric Units</span>
                                    </label>
                                    
                                    <div className="flex items-center gap-2">
                                        <span className="text-sm text-gray-400">Ranges:</span>
                                        <select
                                            value={rangeHandling}
                                            onChange={(e) => setRangeHandling(e.target.value)}
                                            className="bg-gray-700 text-gray-100 px-2 py-1 rounded border border-gray-600 focus:border-green-400 focus:outline-none text-sm"
                                        >
                                            <option value="low">Low (1-2 ‚Üí 1)</option>
                                            <option value="average">Average (1-2 ‚Üí 1.5)</option>
                                            <option value="high">High (1-2 ‚Üí 2)</option>
                                        </select>
                                    </div>
                                </div>

                                <div className="mt-4 flex gap-2">
                                    <input
                                        type="text"
                                        value={recipeName}
                                        onChange={(e) => setRecipeName(e.target.value)}
                                        placeholder="Recipe name (optional)"
                                        className="flex-1 bg-gray-700 text-gray-100 p-2 rounded border border-gray-600 focus:border-green-400 focus:outline-none"
                                    />
                                    <button
                                        onClick={saveRecipe}
                                        className="px-4 py-2 bg-green-600 hover:bg-green-700 rounded font-semibold"
                                    >
                                        Save Recipe
                                    </button>
                                </div>
                            </div>

                            {/* Output Section */}
                            <div className="bg-gray-800 rounded-lg shadow-xl p-6">
                                <div className="flex justify-between items-center mb-4">
                                    <h2 className="text-xl font-bold text-green-400">
                                        Scaled Recipe ({targetServings} servings)
                                    </h2>
                                    {parsedIngredients.length > 0 && (
                                        <button
                                            onClick={copyToClipboard}
                                            className="px-4 py-2 bg-green-600 hover:bg-green-700 rounded font-semibold text-sm flex items-center gap-2"
                                        >
                                            {copySuccess ? '‚úì Copied!' : 'üìã Copy Recipe'}
                                        </button>
                                    )}
                                </div>

                                {parsedIngredients.length === 0 ? (
                                    <div className="text-gray-400 text-center py-8">
                                        Paste ingredients to see scaled results
                                    </div>
                                ) : (
                                    <div className="space-y-2">
                                        {parsedIngredients.map((ingredient, idx) => {
                                            const scaled = scaleIngredient(ingredient);
                                            return (
                                                <div key={idx} className="bg-gray-700 p-3 rounded">
                                                    <div className="flex justify-between items-start">
                                                        <div>
                                                            <span className="text-green-400 font-bold">
                                                                {formatNumber(scaled.value)} {scaled.unit}
                                                            </span>
                                                            <span className="text-gray-100 ml-2">
                                                                {ingredient.ingredient}
                                                            </span>
                                                            {ingredient.isRange && ingredient.rangeOriginal && (
                                                                <span className="ml-2 text-xs text-yellow-400" title={`Original range: ${ingredient.rangeOriginal} ${ingredient.unit}`}>
                                                                    [from {ingredient.rangeOriginal} {ingredient.unit !== 'count' ? ingredient.unit : ''}]
                                                                </span>
                                                            )}
                                                        </div>
                                                        <div className="text-xs text-gray-500">
                                                            {ingredient.quantity} {ingredient.unit}
                                                        </div>
                                                    </div>
                                                </div>
                                            );
                                        })}
                                    </div>
                                )}

                                {parsedIngredients.length > 0 && (
                                    <div className="mt-4 p-3 bg-gray-700 rounded text-sm text-gray-400">
                                        <div>Parsed: {parsedIngredients.length} ingredients</div>
                                        <div>Scale factor: {(targetServings / originalServings).toFixed(2)}x</div>
                                    </div>
                                )}
                            </div>
                        </div>

                        <div className="mt-6 bg-gray-800 rounded-lg shadow-xl p-4 text-sm text-gray-400">
                            <strong className="text-green-400">Tips:</strong>
                            <ul className="mt-2 space-y-1 list-disc list-inside">
                                <li>Supports formats like: "2 cups flour", "1/2 tsp salt", "2 1/2 cups water", "250g sugar", "3 eggs"</li>
                                <li>Handles whole items: "2 potatoes", "1 onion", "4 chicken breasts"</li>
                                <li>Handles messy copy-paste - ignores extra text and instructions</li>
                                <li>Smart unit conversion: 96 tsp ‚Üí 2 cups (or metric equivalent)</li>
                                <li>Supports ranges: "1-2 cups" or "2-3 eggs" - see original range in yellow text</li>
                                <li>Mixed fractions: "2 1/2 cups" works perfectly</li>
                            </ul>
                        </div>
                    </div>
                </div>
            );
        }

        ReactDOM.render(<RecipeScaler />, document.getElementById('root'));
    </script>
</body>
</html>
