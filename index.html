<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smart Recipe Scaler</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-900 text-gray-100">
    <div id="root"></div>

    <script type="text/babel">
        /* ============================================================================
         * SMART RECIPE SCALER
         * ============================================================================
         * 
         * PURPOSE:
         * Intelligently scales recipe ingredients from one serving size to another
         * with smart unit conversions and custom measurement handling.
         * 
         * KEY FEATURES:
         * 1. Parses messy recipe text (handles fractions, ranges, unicode, counts)
         * 2. Scales quantities proportionally based on serving size
         * 3. Smart unit display (e.g., 96 tsp → 2 cups, ½ bulb → 6 cloves)
         * 4. Custom conversions for ambiguous units (bulbs, cloves, bunches, etc.)
         * 5. Bidirectional conversions (can go both ways)
         * 6. Range handling (1-2 cups → use low/average/high)
         * 7. Clean text layout with edit mode toggle
         * 8. Alternative ingredient scaling (or 4 thighs)
         * 
         * ARCHITECTURE:
         * - Single-file React app with Tailwind CSS
         * - LocalStorage for custom conversions and saved recipes
         * - Three main sections: Input, Scaler Output, Conversion Preferences
         * - Edit mode toggle for advanced controls
         *
         * ============================================================================
         * 2-STAGE SCALING SYSTEM
         * ============================================================================
         * 
         * CORE PRINCIPLE: Normalize first, scale, then format.
         * Never scale a recipe that still has mixed units.
         * 
         * STAGE 1 — NORMALIZE EVERYTHING FIRST
         * Before scaling, convert every ingredient into one base unit.
         * Each ingredient is expressed as one number in one unit.
         * 
         *   Liquids → milliliters (mL) internally
         *     • 1 tsp = 5 mL
         *     • 1 tbsp = 15 mL  
         *     • 1 cup = 240 mL
         *     • 1 pint = 473 mL
         *     • 1 quart = 946 mL
         *     • 1 gallon = 3785 mL
         * 
         *   Dry ingredients → grams (g) internally
         *     • Flour ≈ 120 g per cup
         *     • White sugar ≈ 200 g per cup
         *     • Brown sugar ≈ 220 g per cup (packed)
         *     • Salt ≈ 18 g per tbsp
         * 
         *   Bulk solids (nuts, chips) → grams (g)
         *   Meats → grams (or pounds)
         * 
         * STAGE 2 — FORMAT BACK INTO PRACTICAL KITCHEN UNITS
         * Once scaled in grams or mL, convert back to natural kitchen units.
         * Maximum 2 units in display (e.g., "2 gal + 1 cup" is fine).
         * 
         *   LIQUIDS (from mL):
         *     • Under 15 mL → teaspoons
         *     • 15–90 mL → tablespoons
         *     • 90–500 mL → cups
         *     • 500–2000 mL → cups or quarts
         *     • 2000–8000 mL → quarts
         *     • Over 8000 mL → gallons + cups if needed
         * 
         *   DRY POWDERS (from grams):
         *     • Under 10 g → teaspoons
         *     • 10–50 g → tablespoons
         *     • 50–300 g → cups
         *     • 300–2000 g → pounds
         *     • Over 2000 g → pounds + ounces
         * 
         *   BULK SOLIDS - nuts, chocolate, etc. (from grams):
         *     • Under 50 g → tablespoons
         *     • 50–200 g → cups
         *     • 200–1500 g → pounds
         *     • Over 1500 g → pounds + ounces
         * 
         *   MEAT (from grams):
         *     • Under 200 g → grams
         *     • 200–2000 g → pounds
         *     • Over 2000 g → pounds + ounces
         * 
         * INGREDIENT CLASSIFICATIONS:
         * 1. Liquids: water, milk, juice, broth, wine, etc.
         * 2. Dry Powders: flour, cocoa, powdered sugar, cornstarch
         * 3. Granular: sugar, salt, rice, lentils, quinoa
         * 4. Leafy/Herbs: parsley, cilantro, basil, oregano, mint
         * 5. Fats: butter, shortening, lard
         * 6. Viscous: honey, molasses, syrup
         * 7. Strong Spices: clove, nutmeg, cayenne
         * 8. Bulk Solids: nuts, chocolate chips, chopped items
         * 9. Meat: chicken, beef, pork, etc.
         * 10. Countable: eggs, cloves, carrots, shrimp
         * 
         * ROUNDING RULES:
         * - Teaspoons: nearest ¼ tsp
         * - Tablespoons: nearest ¼ tbsp
         * - Cups: nearest ¼ or ⅓ cup (whichever closer)
         * - Pounds: nearest ¼ lb
         * - Milliliters: whole numbers
         * - Grams: whole numbers
         * - Liters/Kilograms: 1 decimal place
         * 
         * ============================================================================
         */

        const { useState, useEffect } = React;

        // ============================================================================
        // UNIT CONVERSION CONSTANTS
        // ============================================================================
        // All volume measurements converted to teaspoons as base unit
        const VOLUME_CONVERSIONS = {
            // To teaspoons (base unit)
            'tsp': 1,
            'teaspoon': 1,
            'teaspoons': 1,
            'tsps': 1,
            'pinch': 0.125,  // ~1/8 tsp
            'dash': 0.125,   // ~1/8 tsp
            'drop': 0.01,    // ~0.05 mL, roughly 1/100 tsp
            'drops': 0.01,
            'tbsp': 3,
            'tbsps': 3,
            'tablespoon': 3,
            'tablespoons': 3,
            'floz': 6,
            'fl oz': 6,
            'fluid ounce': 6,
            'fluid ounces': 6,
            'cup': 48,
            'cups': 48,
            'c': 48,
            'pint': 96,
            'pints': 96,
            'pt': 96,
            'pts': 96,
            'quart': 192,
            'quarts': 192,
            'qt': 192,
            'qts': 192,
            'gallon': 768,
            'gallons': 768,
            'gal': 768,
            'gals': 768,
            // Metric
            'ml': 0.202884,
            'milliliter': 0.202884,
            'milliliters': 0.202884,
            'l': 202.884,
            'liter': 202.884,
            'liters': 202.884,
        };

        // All weight measurements converted to grams as base unit
        const WEIGHT_CONVERSIONS = {
            // To grams (base unit)
            'g': 1,
            'gram': 1,
            'grams': 1,
            'kg': 1000,
            'kilogram': 1000,
            'kilograms': 1000,
            'oz': 28.3495,
            'ounce': 28.3495,
            'ounces': 28.3495,
            'lb': 453.592,
            'lbs': 453.592,
            'pound': 453.592,
            'pounds': 453.592,
        };

        // ============================================================================
        // INGREDIENT DENSITY AND CLASSIFICATION SYSTEM
        // ============================================================================
        // Comprehensive density table for accurate volume-to-weight conversions
        // All densities in grams per cup (240ml)
        
        const INGREDIENT_DENSITIES = {
            // Liquids (water-based)
            'water': 240,
            'milk': 245,
            'cream': 240,
            'broth': 240,
            'stock': 240,
            'juice': 240,
            'wine': 235,
            'beer': 240,
            'oil': 220,
            'olive oil': 216,
            'vegetable oil': 220,
            'honey': 340,
            'molasses': 340,
            'syrup': 330,
            'maple syrup': 330,
            
            // Dry powdered solids
            'flour': 120,
            'all-purpose flour': 120,
            'bread flour': 127,
            'cake flour': 114,
            'whole wheat flour': 120,
            'cocoa': 100,
            'cocoa powder': 100,
            'powdered sugar': 120,
            'confectioners sugar': 120,
            'cornstarch': 128,
            
            // Granular solids
            'sugar': 200,
            'granulated sugar': 200,
            'brown sugar': 220,
            'salt': 292,
            'kosher salt': 146,
            'sea salt': 292,
            'rice': 185,
            'white rice': 185,
            'lentils': 192,
            'quinoa': 170,
            'oats': 102,
            'rolled oats': 102,
            
            // Fats
            'butter': 227,
            'shortening': 192,
            'lard': 205,
            'margarine': 227,
            
            // Nuts and seeds
            'almonds': 143,
            'walnuts': 117,
            'pecans': 109,
            'peanuts': 146,
            'cashews': 130,
            
            // Cheese
            'parmesan': 100,
            'cheddar': 113,
            'mozzarella': 113,
            
            // Default fallbacks
            'powder': 120,
            'grain': 185,
            'liquid': 240
        };
        
        // Ingredient classification for conversion logic
        const INGREDIENT_CLASSES = {
            liquids: ['water', 'milk', 'cream', 'broth', 'stock', 'juice', 'wine', 'beer', 'oil', 'olive oil', 
                     'vegetable oil', 'coconut oil', 'sesame oil'],
            dryPowders: ['flour', 'all-purpose flour', 'bread flour', 'cake flour', 'whole wheat flour', 
                        'cocoa', 'cocoa powder', 'powdered sugar', 'confectioners sugar', 'cornstarch', 'baking powder', 
                        'baking soda'],
            granular: ['sugar', 'granulated sugar', 'brown sugar', 'salt', 'kosher salt', 'sea salt', 
                      'rice', 'white rice', 'lentils', 'quinoa', 'oats', 'rolled oats'],
            leafyHerbs: ['parsley', 'cilantro', 'basil', 'oregano', 'mint', 'thyme', 'rosemary', 'dill', 
                        'chives', 'spinach', 'lettuce', 'arugula'],
            fats: ['butter', 'shortening', 'lard', 'margarine', 'coconut oil'],
            viscous: ['honey', 'molasses', 'syrup', 'maple syrup', 'corn syrup'],
            strongSpices: ['clove', 'cloves', 'nutmeg', 'cayenne', 'cinnamon', 'ginger', 'turmeric', 'paprika'],
            countable: ['egg', 'eggs', 'clove', 'cloves', 'garlic clove', 'garlic cloves', 'onion', 'onions', 
                       'carrot', 'carrots', 'potato', 'potatoes', 'shrimp', 'meatball', 'meatballs']
        };
        
        // Helper function to classify ingredient
        const classifyIngredient = (ingredientName) => {
            const lower = ingredientName.toLowerCase();
            
            for (const [category, items] of Object.entries(INGREDIENT_CLASSES)) {
                for (const item of items) {
                    if (lower.includes(item)) {
                        return category;
                    }
                }
            }
            
            // Default classification
            return 'unknown';
        };
        
        // Helper function to get ingredient density
        const getIngredientDensity = (ingredientName) => {
            const lower = ingredientName.toLowerCase();
            
            // Try exact match first
            if (INGREDIENT_DENSITIES[lower]) {
                return INGREDIENT_DENSITIES[lower];
            }
            
            // Try partial matches
            for (const [key, density] of Object.entries(INGREDIENT_DENSITIES)) {
                if (lower.includes(key) || key.includes(lower)) {
                    return density;
                }
            }
            
            // Return defaults based on classification
            const classification = classifyIngredient(ingredientName);
            if (classification === 'dryPowders') return 120;
            if (classification === 'granular') return 185;
            if (classification === 'liquids') return 240;
            if (classification === 'fats') return 220;
            
            // Ultimate fallback
            return 125;
        };

        // ============================================================================
        // 2-STAGE SCALING SYSTEM
        // ============================================================================
        // Stage 1: Normalize to base units (mL for liquids, g for solids)
        // Stage 2: Format back into practical kitchen units based on quantity
        //
        // Core Principle: Normalize first, scale, then format.
        // Never display mixed units like "1 gallon + 14 cups"
        // Maximum 2 units in display (e.g., "2 lb + 4 oz" is fine)
        
        /* STAGE 2: FORMAT LIQUIDS (from mL)
         * Thresholds for US:
         * - Under 15 mL → teaspoons
         * - 15–90 mL → tablespoons  
         * - 90–500 mL → cups
         * - 500–2000 mL → pints or quarts
         * - 2000–8000 mL → quarts
         * - Over 8000 mL → gallons + cups if needed
         */
        const smartConvertVolume = (tsp, useMetric, ingredientName = '', rules = {}) => {
            // Convert from tsp (internal base) to mL (Stage 1 base)
            const ml = tsp * 4.92892; // 1 tsp = 4.92892 mL
            
            // Default rules
            const noFractionalQuarts = rules.noFractionalQuarts !== false; // default true
            const noFractionalGallons = rules.noFractionalGallons !== false; // default true
            
            if (useMetric) {
                // Metric: display in mL or L
                if (ml < 1) {
                    return { value: 0, unit: 'pinch' };
                }
                if (ml < 1000) {
                    return { value: Math.round(ml), unit: 'ml' };
                }
                // >= 1000 mL: use liters
                const liters = ml / 1000;
                if (liters < 10) {
                    return { value: Math.round(liters * 10) / 10, unit: 'L' };
                }
                return { value: Math.round(liters), unit: 'L' };
            }
            
            // US Customary formatting
            
            // Under 15 mL → teaspoons
            if (ml < 15) {
                if (ml < 0.5) {
                    return { value: 0, unit: 'pinch' };
                }
                const tspVal = ml / 4.92892;
                const rounded = Math.round(tspVal * 4) / 4; // nearest ¼ tsp
                return { value: rounded, unit: 'tsp' };
            }
            
            // 15–90 mL → tablespoons
            if (ml < 90) {
                const tbsp = ml / 14.787;
                const rounded = Math.round(tbsp * 4) / 4; // nearest ¼ tbsp
                return { value: rounded, unit: 'tbsp' };
            }
            
            // 90–500 mL → cups
            if (ml < 500) {
                const cups = ml / 240;
                // Round to nearest ¼ or ⅓ cup (whichever is closer)
                const roundedQuarter = Math.round(cups * 4) / 4;
                const roundedThird = Math.round(cups * 3) / 3;
                const rounded = Math.abs(cups - roundedQuarter) < Math.abs(cups - roundedThird) 
                    ? roundedQuarter : roundedThird;
                return { value: rounded, unit: 'cup' };
            }
            
            // 500–2000 mL → cups or quarts
            if (ml < 2000) {
                const cups = ml / 240;
                if (cups <= 4) {
                    const rounded = Math.round(cups * 4) / 4;
                    return { value: rounded, unit: 'cup' };
                }
                // Use quarts for > 4 cups
                const quarts = ml / 946;
                
                if (noFractionalQuarts) {
                    // Never show fractional quarts - always use qt + cups
                    const wholeQuarts = Math.floor(quarts);
                    const remainingMl = ml - (wholeQuarts * 946);
                    const remainingCups = remainingMl / 240;
                    const roundedCups = Math.round(remainingCups * 4) / 4;
                    
                    if (wholeQuarts === 0) {
                        return { value: roundedCups, unit: 'cup' };
                    }
                    if (roundedCups >= 0.25) {
                        return { value: wholeQuarts, unit: 'qt', remainder: roundedCups, remainderUnit: 'cup' };
                    }
                    return { value: wholeQuarts, unit: 'qt' };
                } else {
                    // Allow fractional quarts
                    const rounded = Math.round(quarts * 4) / 4;
                    return { value: rounded, unit: 'qt' };
                }
            }
            
            // 2000–8000 mL → quarts (with no-fractional rule)
            if (ml < 8000) {
                const quarts = ml / 946;
                
                if (noFractionalQuarts) {
                    const wholeQuarts = Math.floor(quarts);
                    const remainingMl = ml - (wholeQuarts * 946);
                    const remainingCups = remainingMl / 240;
                    const roundedCups = Math.round(remainingCups * 4) / 4;
                    
                    if (roundedCups >= 0.25) {
                        return { value: wholeQuarts, unit: 'qt', remainder: roundedCups, remainderUnit: 'cup' };
                    }
                    return { value: wholeQuarts, unit: 'qt' };
                } else {
                    const rounded = Math.round(quarts * 4) / 4;
                    return { value: rounded, unit: 'qt' };
                }
            }
            
            // Over 8000 mL → gallons (with no-fractional rule)
            const gallons = ml / 3785;
            
            if (noFractionalGallons) {
                const wholeGallons = Math.floor(gallons);
                const remainingMl = ml - (wholeGallons * 3785);
                
                // Remainder as quarts or cups
                const remainingQuarts = remainingMl / 946;
                if (remainingQuarts >= 1 && noFractionalQuarts) {
                    const wholeRemainingQuarts = Math.floor(remainingQuarts);
                    const remainingAfterQuarts = remainingMl - (wholeRemainingQuarts * 946);
                    const remainingCups = remainingAfterQuarts / 240;
                    const roundedCups = Math.round(remainingCups * 4) / 4;
                    
                    // gal + qt (skip cups for simplicity at this scale)
                    if (wholeRemainingQuarts > 0) {
                        return { value: wholeGallons, unit: 'gal', remainder: wholeRemainingQuarts, remainderUnit: 'qt' };
                    }
                }
                
                const remainingCups = remainingMl / 240;
                const roundedCups = Math.round(remainingCups * 4) / 4;
                if (roundedCups >= 0.5) {
                    return { value: wholeGallons, unit: 'gal', remainder: roundedCups, remainderUnit: 'cup' };
                }
                return { value: wholeGallons, unit: 'gal' };
            } else {
                const rounded = Math.round(gallons * 4) / 4;
                return { value: rounded, unit: 'gal' };
            }
        };

        /* STAGE 2: FORMAT DRY POWDERS (from grams)
         * For flour, sugar, salt, powders
         * Thresholds for US:
         * - Under 10 g → teaspoons
         * - 10–50 g → tablespoons
         * - 50–300 g → cups
         * - 300–2000 g → pounds
         * - Over 2000 g → pounds + ounces
         */
        const formatDryPowder = (g, useMetric, density = 125, rules = {}) => {
            const noFractionalPounds = rules.noFractionalPounds || false;
            
            if (useMetric) {
                if (g < 1) return { value: 0, unit: 'pinch' };
                if (g < 1000) return { value: Math.round(g), unit: 'g' };
                return { value: Math.round(g / 100) / 10, unit: 'kg' };
            }
            
            // Under 10g → teaspoons (approx 3g per tsp for powders)
            if (g < 10) {
                if (g < 1) return { value: 0, unit: 'pinch' };
                const tsp = g / 3;
                return { value: Math.round(tsp * 4) / 4, unit: 'tsp' };
            }
            
            // 10–50g → tablespoons (approx 9g per tbsp)
            if (g < 50) {
                const tbsp = g / 9;
                return { value: Math.round(tbsp * 4) / 4, unit: 'tbsp' };
            }
            
            // 50–300g → cups (use density)
            if (g < 300) {
                const cups = g / density;
                const roundedQuarter = Math.round(cups * 4) / 4;
                const roundedThird = Math.round(cups * 3) / 3;
                const rounded = Math.abs(cups - roundedQuarter) < Math.abs(cups - roundedThird)
                    ? roundedQuarter : roundedThird;
                return { value: rounded, unit: 'cup' };
            }
            
            // 300g+ → pounds (with optional no-fractional rule)
            const lb = g / 453.592;
            
            if (noFractionalPounds || g >= 2000) {
                // Always use lb + oz for large amounts or when rule is enabled
                const wholeLb = Math.floor(lb);
                const remainingG = g - (wholeLb * 453.592);
                const oz = remainingG / 28.3495;
                if (oz >= 1) {
                    return { value: wholeLb, unit: 'lb', remainder: Math.round(oz), remainderUnit: 'oz' };
                }
                if (wholeLb > 0) {
                    return { value: wholeLb, unit: 'lb' };
                }
                // Less than 1 lb, show in oz
                return { value: Math.round(g / 28.3495), unit: 'oz' };
            }
            
            // Allow fractional pounds
            return { value: Math.round(lb * 4) / 4, unit: 'lb' };
        };

        /* STAGE 2: FORMAT BULK SOLIDS (from grams)
         * For nuts, chocolate chips, chopped items
         * Thresholds for US:
         * - Under 50 g → tablespoons
         * - 50–200 g → cups
         * - 200–1500 g → pounds
         * - Over 1500 g → pounds + ounces
         */
        const formatBulkSolid = (g, useMetric, density = 150, rules = {}) => {
            const noFractionalPounds = rules.noFractionalPounds || false;
            
            if (useMetric) {
                if (g < 1000) return { value: Math.round(g), unit: 'g' };
                return { value: Math.round(g / 100) / 10, unit: 'kg' };
            }
            
            // Under 50g → tablespoons
            if (g < 50) {
                const tbsp = g / 15;
                return { value: Math.round(tbsp * 4) / 4, unit: 'tbsp' };
            }
            
            // 50–200g → cups
            if (g < 200) {
                const cups = g / density;
                const roundedQuarter = Math.round(cups * 4) / 4;
                const roundedThird = Math.round(cups * 3) / 3;
                const rounded = Math.abs(cups - roundedQuarter) < Math.abs(cups - roundedThird)
                    ? roundedQuarter : roundedThird;
                return { value: rounded, unit: 'cup' };
            }
            
            // 200g+ → pounds
            const lb = g / 453.592;
            
            if (noFractionalPounds || g >= 1500) {
                const wholeLb = Math.floor(lb);
                const remainingG = g - (wholeLb * 453.592);
                const oz = remainingG / 28.3495;
                if (oz >= 1) {
                    return { value: wholeLb, unit: 'lb', remainder: Math.round(oz), remainderUnit: 'oz' };
                }
                if (wholeLb > 0) {
                    return { value: wholeLb, unit: 'lb' };
                }
                return { value: Math.round(g / 28.3495), unit: 'oz' };
            }
            
            return { value: Math.round(lb * 4) / 4, unit: 'lb' };
        };

        /* STAGE 2: FORMAT MEAT (from grams)
         * Thresholds for US:
         * - Under 200 g → grams (too small for lb)
         * - 200–500 g → about ½–1 lb
         * - 500–2000 g → pounds
         * - Over 2000 g → pounds + ounces
         */
        const formatMeat = (g, useMetric, rules = {}) => {
            const noFractionalPounds = rules.noFractionalPounds || false;
            
            if (useMetric) {
                if (g < 250) return { value: Math.round(g), unit: 'g' };
                if (g < 1000) return { value: Math.round(g / 100) / 10, unit: 'kg' };
                return { value: Math.round(g / 100) / 10, unit: 'kg' };
            }
            
            // Under 200g → just show grams (awkward in lb)
            if (g < 200) {
                return { value: Math.round(g), unit: 'g' };
            }
            
            // 200g+ → pounds
            const lb = g / 453.592;
            
            if (noFractionalPounds || g >= 2000) {
                const wholeLb = Math.floor(lb);
                const remainingG = g - (wholeLb * 453.592);
                const oz = remainingG / 28.3495;
                if (oz >= 1) {
                    return { value: wholeLb, unit: 'lb', remainder: Math.round(oz), remainderUnit: 'oz' };
                }
                if (wholeLb > 0) {
                    return { value: wholeLb, unit: 'lb' };
                }
                return { value: Math.round(g / 28.3495), unit: 'oz' };
            }
            
            return { value: Math.round(lb * 4) / 4, unit: 'lb' };
        };

        /* SMART WEIGHT CONVERSION
         * Determines ingredient type and routes to appropriate formatter
         * Input: grams (base unit from Stage 1)
         * Unknown ingredients default to simple weight display (g or oz)
         */
        const smartConvertWeight = (g, useMetric, ingredientName = '', rules = {}) => {
            const lower = ingredientName.toLowerCase();
            
            // Classify ingredient
            const classification = classifyIngredient(ingredientName);
            const density = getIngredientDensity(ingredientName);
            
            // Route to appropriate formatter based on classification
            if (classification === 'dryPowders' || classification === 'granular') {
                return formatDryPowder(g, useMetric, density, rules);
            }
            
            if (classification === 'leafyHerbs' || classification === 'strongSpices') {
                // Herbs and spices: always small amounts, use tsp/tbsp
                return formatDryPowder(g, useMetric, density, rules);
            }
            
            if (classification === 'fats') {
                // Fats like butter - use dry powder logic (works well for tbsp/cups)
                return formatDryPowder(g, useMetric, density, rules);
            }
            
            // Check for meat keywords
            if (lower.includes('chicken') || lower.includes('beef') || lower.includes('pork') ||
                lower.includes('lamb') || lower.includes('turkey') || lower.includes('meat') ||
                lower.includes('steak') || lower.includes('roast') || lower.includes('ground') ||
                lower.includes('sausage') || lower.includes('bacon') || lower.includes('ham')) {
                return formatMeat(g, useMetric, rules);
            }
            
            // Check for bulk solid keywords (nuts, chips, etc.)
            if (lower.includes('nut') || lower.includes('chip') || lower.includes('chopped') ||
                lower.includes('diced') || lower.includes('almond') || lower.includes('walnut') ||
                lower.includes('pecan') || lower.includes('cashew') || lower.includes('raisin') ||
                lower.includes('cranberr') || lower.includes('chocolate') || lower.includes('seed')) {
                return formatBulkSolid(g, useMetric, density, rules);
            }
            
            // UNKNOWN INGREDIENT: Safe fallback - just show weight directly
            const noFractionalPounds = rules.noFractionalPounds || false;
            
            if (useMetric) {
                if (g < 1) return { value: 0, unit: 'pinch' };
                if (g < 1000) return { value: Math.round(g), unit: 'g' };
                return { value: Math.round(g / 100) / 10, unit: 'kg' };
            } else {
                // Imperial: show in oz for small amounts, lb for large
                if (g < 1) return { value: 0, unit: 'pinch' };
                const oz = g / 28.3495;
                if (oz < 16) {
                    return { value: Math.round(oz * 4) / 4, unit: 'oz' };
                }
                const lb = g / 453.592;
                
                if (noFractionalPounds) {
                    const wholeLb = Math.floor(lb);
                    const remainingOz = (g - wholeLb * 453.592) / 28.3495;
                    if (remainingOz >= 1) {
                        return { value: wholeLb, unit: 'lb', remainder: Math.round(remainingOz), remainderUnit: 'oz' };
                    }
                    return { value: wholeLb, unit: 'lb' };
                }
                
                return { value: Math.round(lb * 4) / 4, unit: 'lb' };
            }
        };

        // ============================================================================
        // DISPLAY FORMATTING FUNCTIONS
        // ============================================================================
        
        /* FORMAT COMPOUND MEASUREMENTS
         * Displays scaled measurements with proper unit handling:
         * - Count items (eggs, onions): Show number only, no unit
         * - Compound units (1 cup + 2 tbsp): Show with " + " separator
         * - Single units: Show number + pluralized unit
         */
        const formatCompoundMeasurement = (scaled) => {
            // DEBUG: Log the scaled object to see what's actually in it
            if (scaled.unit === 'tsp' || scaled.unit === 'tsps') {
                console.log('DEBUG formatCompoundMeasurement:', JSON.stringify(scaled, null, 2));
            }
            
            // Defensive: ensure value is a number, not a string with fractions
            let cleanValue = typeof scaled.value === 'string' ? parseFloat(scaled.value) : scaled.value;
            let cleanRemainder = typeof scaled.remainder === 'string' ? parseFloat(scaled.remainder) : scaled.remainder;
            
            // For count items, don't display the unit - it's handled by the ingredient name
            if (scaled.unit === 'count' || scaled.unit === '') {
                if (cleanRemainder && scaled.remainderUnit && scaled.remainderUnit !== 'count' && scaled.remainderUnit !== '') {
                    // Count with a remainder in different unit (rare case)
                    return (
                        <>
                            {formatNumber(cleanValue)}
                            <span className="text-gray-300"> + </span>
                            {formatNumber(cleanRemainder)} {pluralize(cleanRemainder, scaled.remainderUnit)}
                        </>
                    );
                }
                return <>{formatNumber(cleanValue)}</>;
            }
            
            // Regular volume/weight measurements with units
            const unitText = pluralize(cleanValue, scaled.unit);
            if (cleanRemainder && scaled.remainderUnit) {
                const remainderUnitText = pluralize(cleanRemainder, scaled.remainderUnit);
                // Two-part compound measurement
                return (
                    <>
                        {formatNumber(cleanValue)} {unitText}
                        <span className="text-gray-300"> + </span>
                        {formatNumber(cleanRemainder)} {remainderUnitText}
                    </>
                );
            }
            return <>{formatNumber(cleanValue)} {unitText}</>;
        };

        // ============================================================================
        // INGREDIENT PARSING ENGINE
        // ============================================================================
        
        /* PARSE INGREDIENT LINE
         * Complex regex-based parser that handles many formats:
         * - "2 cups flour" (standard)
         * - "1/2 tsp salt" (fraction)
         * - "2 1/2 cups water" (mixed fraction)
         * - "1½ cups milk" (unicode fraction with/without space)
         * - "1-2 cups sugar" (range)
         * - "3 eggs" (count)
         * - "salt to taste" (seasoning)
         * 
         * Returns parsed object with:
         * - quantity: numeric value
         * - unit: the measurement unit
         * - ingredient: the ingredient name
         * - type: 'volume', 'weight', 'count', or 'seasoning'
         * - isRange: boolean for range measurements
         * - rangeOriginal: original range string if applicable
         */
        const parseIngredient = (line, rangeMode = 'average') => {
            line = line.trim();
            if (!line) return null;

            // Remove common prefixes
            line = line.replace(/^[-•*]\s*/, '');
            
            // Normalize dashes - convert en dash (–) and em dash (—) to regular hyphen (-)
            line = line.replace(/[–—]/g, '-');
            
            // Ignore header lines (all caps or common recipe section headers)
            if (line.match(/^(ingredients|directions|instructions|serves|servings|yield|method|preparation|notes?|tips?)/i)) {
                return null;
            }
            
            // Ignore all-caps lines (likely section headers)
            if (line === line.toUpperCase() && line.length > 3 && /[A-Z]/.test(line)) {
                return null;
            }
            
            // Store original for "to taste" handling
            const originalLine = line;
            
            // Parse parenthetical content for alternatives (e.g., "or 4 thighs") or equivalents (e.g., "200g")
            const parenMatch = line.match(/^(.+?)(\([^)]+\))(.*)$/);
            let notes = '';
            let alternative = null; // Will store parsed alternative ingredient
            
            if (parenMatch) {
                const beforeParen = parenMatch[1].trim();
                const parenContent = parenMatch[2];
                const afterParen = parenMatch[3].trim();
                
                // Check if this is a weight/volume equivalent like "(200g)" or "(1 cup)"
                // These should be noted but the ingredient comes AFTER the paren
                const equivMatch = parenContent.match(/^\((\d+\.?\d*)\s*(g|kg|oz|lb|lbs|ml|l|cup|cups|tbsp|tsp)\)$/i);
                if (equivMatch && afterParen) {
                    // This is "1 cup (200g) brown sugar" format
                    // Keep "1 cup brown sugar" as the line, note the equivalent
                    line = beforeParen + ' ' + afterParen;
                    notes = parenContent; // Store "(200g)" as a note
                } else if (afterParen) {
                    // Paren in middle with content after - reconstruct without paren
                    line = beforeParen + ' ' + afterParen;
                    notes = parenContent;
                    
                    // Check if parentheses contain an alternative ingredient (starts with "or")
                    const altMatch = parenContent.match(/\(or\s+(.+?)\)/i);
                    if (altMatch) {
                        const altText = altMatch[1].trim();
                        const altParsed = parseIngredient(altText, rangeMode);
                        if (altParsed && altParsed.quantity) {
                            alternative = {
                                quantity: altParsed.quantity,
                                unit: altParsed.unit,
                                ingredient: altParsed.ingredient,
                                type: altParsed.type,
                                baseValue: altParsed.baseValue,
                                isRange: altParsed.isRange,
                                rangeOriginal: altParsed.rangeOriginal
                            };
                        }
                    }
                } else {
                    // Paren at end - original behavior
                    line = beforeParen;
                    notes = parenContent;
                    
                    // Check if parentheses contain an alternative ingredient (starts with "or")
                    const altMatch = parenContent.match(/\(or\s+(.+?)\)/i);
                    if (altMatch) {
                        const altText = altMatch[1].trim();
                        const altParsed = parseIngredient(altText, rangeMode);
                        if (altParsed && altParsed.quantity) {
                            alternative = {
                                quantity: altParsed.quantity,
                                unit: altParsed.unit,
                                ingredient: altParsed.ingredient,
                                type: altParsed.type,
                                baseValue: altParsed.baseValue,
                                isRange: altParsed.isRange,
                                rangeOriginal: altParsed.rangeOriginal
                            };
                        }
                    }
                }
            }
            
            // Handle "to taste" - these are non-quantifiable
            if (line.match(/to taste/i)) {
                // Extract ingredient name before "to taste"
                const ingredient = line.replace(/,?\s*to taste.*/i, '').trim();
                return {
                    original: originalLine,
                    quantity: null,
                    unit: 'to taste',
                    ingredient: ingredient,
                    type: 'seasoning',
                    baseValue: 0,
                    isRange: false,
                    rangeOriginal: null,
                    notes: notes,
                            alternative
                };
            }
            
            // Try to match: quantity unit ingredient
            // Supports: "2 cups flour", "1/2 cup sugar", "2 1/2 cups water", "2-1/2 cups" (mixed fraction), "1.5 tsp salt", "2.25 cups milk", "2-3 cups water", "3 eggs"
            const patterns = [
                // Whole number + unicode fraction with space + unit: "11 ½ tsps salt" (MUST BE FIRST!)
                /^(\d+)\s+([½⅓⅔¼¾⅛⅜⅝⅞])\s+([a-zA-Z]+)\s+(.+)$/,
                // Whole number + unicode fraction (no space) + unit: "11½ tsps salt"
                /^(\d+)([½⅓⅔¼¾⅛⅜⅝⅞])\s+([a-zA-Z]+)\s+(.+)$/,
                // Compound measurement: "1 qt 1/4 cups butter" or "1 qt ¼ cups butter"
                /^(\d+)\s+([a-zA-Z]+)\s+(\d+\/\d+|[½⅓⅔¼¾⅛⅜⅝⅞])\s+([a-zA-Z]+)\s+(.+)$/,
                // Mixed fraction with unit: "2 1/2 cups" (plain text fraction)
                /^(\d+)\s+(\d+\/\d+)\s+([a-zA-Z]+)\s+(.+)$/,
                // Decimal with unit: "2.25 cups" or "10.5 tablespoons"
                /^(\d+\.\d+)\s+([a-zA-Z]+)\s+(.+)$/,
                // Decimal range with unit: "1.5-3 teaspoons"
                /^(\d+\.?\d*)\s*-\s*(\d+\.?\d*)\s+([a-zA-Z]+)\s+(.+)$/,
                // Ambiguous: could be range or mixed fraction: "2-1/2 cups" or "1-2 cups"
                /^(\d+)\s*-\s*(\d+\/\d+|\d+)\s+([a-zA-Z]+)\s+(.+)$/,
                // Range with mixed fractions: "1 1/2-2 cups" or "2-2 1/2 cups"
                /^(\d+)\s+(\d+\/\d+)\s*-\s*(\d+)\s+(\d+\/\d+)\s+([a-zA-Z]+)\s+(.+)$/,
                /^(\d+)\s*-\s*(\d+)\s+(\d+\/\d+)\s+([a-zA-Z]+)\s+(.+)$/,
                /^(\d+)\s+(\d+\/\d+)\s*-\s*(\d+)\s+([a-zA-Z]+)\s+(.+)$/,
                // Standalone fraction with unit: "1/4 cup" or "1/2 tsp"
                /^(\d+\/\d+)\s+([a-zA-Z]+)\s+(.+)$/,
                // Fraction or decimal with unit (with range support)
                /^(\d+\/\d+|\d+\.\d+)\s*-\s*(\d+\/\d+|\d+\.\d+)\s*([a-zA-Z]+)\s+(.+)$/,
                // Just number with unit
                /^(\d+)\s+([a-zA-Z]+)\s+(.+)$/,
                // Unicode fraction with unit
                /^([½⅓⅔¼¾⅛⅜⅝⅞])\s*([a-zA-Z]+)\s+(.+)$/,
                // Mixed fraction count: "2 1/2 eggs"
                /^(\d+)\s+(\d+\/\d+)\s+(.+)$/,
                // Standalone fraction count: "1/2 onion"
                /^(\d+\/\d+)\s+(.+)$/,
                // Ambiguous count: "2-1/2 eggs" or "2-3 eggs"
                /^(\d+)\s*-\s*(\d+\/\d+|\d+)\s+(.+)$/,
                // Count with range: "2-3 eggs"
                /^(\d+\/\d+|\d+\.\d+)\s*-\s*(\d+\/\d+|\d+\.\d+)\s+(.+)$/,
                // Unicode fraction count only
                /^([½⅓⅔¼¾⅛⅜⅝⅞])\s+(.+)$/,
                // Simple count: "4 eggs" or "3 potatoes"
                /^(\d+)\s+(.+)$/,
            ];

            for (const pattern of patterns) {
                const match = line.match(pattern);
                if (match) {
                    let quantity, unit, ingredient, isRange = false, rangeOriginal = null;
                    
                    // Handle whole number + unicode fraction with space + unit: "11 ½ tsps salt"
                    if (pattern === patterns[0]) {
                        const whole = parseInt(match[1]);
                        const frac = parseUnicodeFraction(match[2]);
                        quantity = whole + frac;
                        unit = match[3].toLowerCase();
                        ingredient = match[4];
                    }
                    // Handle whole number + unicode fraction (no space) + unit: "11½ tsps salt"
                    else if (pattern === patterns[1]) {
                        const whole = parseInt(match[1]);
                        const frac = parseUnicodeFraction(match[2]);
                        quantity = whole + frac;
                        unit = match[3].toLowerCase();
                        ingredient = match[4];
                    }
                    // Handle compound measurement: "1 qt 1/4 cups butter" or "1 qt ¼ cups butter"
                    else if (pattern === patterns[2]) {
                        const mainQty = parseInt(match[1]);
                        const mainUnit = match[2].toLowerCase();
                        const remFrac = match[3];
                        const remUnit = match[4].toLowerCase();
                        ingredient = match[5];
                        
                        // Convert fraction (either unicode or plain text)
                        const remQty = remFrac.match(/\d/) ? parseQuantity(remFrac) : parseUnicodeFraction(remFrac);
                        
                        // Convert both to base unit
                        if (VOLUME_CONVERSIONS[mainUnit] && VOLUME_CONVERSIONS[remUnit]) {
                            const mainTsp = mainQty * VOLUME_CONVERSIONS[mainUnit];
                            const remTsp = remQty * VOLUME_CONVERSIONS[remUnit];
                            quantity = mainTsp + remTsp;
                            unit = 'tsp';
                        } else if (WEIGHT_CONVERSIONS[mainUnit] && WEIGHT_CONVERSIONS[remUnit]) {
                            const mainG = mainQty * WEIGHT_CONVERSIONS[mainUnit];
                            const remG = remQty * WEIGHT_CONVERSIONS[remUnit];
                            quantity = mainG + remG;
                            unit = 'g';
                        } else {
                            // Can't parse, skip
                            continue;
                        }
                    }
                    // Handle mixed fractions with plain text: "2 1/2 cups flour"
                    else if (pattern === patterns[3]) {
                        const whole = parseInt(match[1]);
                        const frac = parseQuantity(match[2]);
                        quantity = whole + frac;
                        unit = match[3].toLowerCase();
                        ingredient = match[4];
                    }
                    // Handle decimal with unit: "2.25 cups milk"
                    else if (pattern === patterns[4]) {
                        quantity = parseFloat(match[1]);
                        unit = match[2].toLowerCase();
                        ingredient = match[3];
                    }
                    // Handle decimal range with unit: "1.5-3 teaspoons"
                    else if (pattern === patterns[5]) {
                        const q1 = parseFloat(match[1]);
                        const q2 = parseFloat(match[2]);
                        isRange = true;
                        rangeOriginal = `${match[1]}-${match[2]}`;
                        quantity = rangeMode === 'low' ? q1 : rangeMode === 'high' ? q2 : (q1 + q2) / 2;
                        unit = match[3].toLowerCase();
                        ingredient = match[4];
                    }
                    // Handle whole number + unicode fraction with space: "1 ½ tsp"
                    else if (pattern === patterns[2]) {
                        const whole = parseInt(match[1]);
                        const frac = parseUnicodeFraction(match[2]);
                        quantity = whole + frac;
                        unit = match[3].toLowerCase();
                        ingredient = match[4];
                    }
                    // Handle whole number + unicode fraction (no space): "1½ lbs"
                    else if (pattern === patterns[3]) {
                        const whole = parseInt(match[1]);
                        const frac = parseUnicodeFraction(match[2]);
                        quantity = whole + frac;
                        unit = match[3].toLowerCase();
                        ingredient = match[4];
                    }
                    // Handle mixed fractions with unit: "2 1/2 cups flour"
                    else if (pattern === patterns[4]) {
                        const whole = parseInt(match[1]);
                        const frac = parseQuantity(match[2]);
                        quantity = whole + frac;
                        unit = match[3].toLowerCase();
                        ingredient = match[4];
                    }
                    // Handle ambiguous "2-1/2" format with unit - could be range or mixed fraction
                    else if (pattern === patterns[5]) {
                        const q1 = parseInt(match[1]);
                        const q2 = parseQuantity(match[2]);
                        
                        // If q1 > q2, treat as mixed fraction (e.g., "2-1/2" = 2.5)
                        // If q1 < q2, treat as range (e.g., "1-2" = range from 1 to 2)
                        if (q1 > q2) {
                            // Mixed fraction: "2-1/2 cups" = 2.5 cups
                            quantity = q1 + q2;
                            unit = match[3].toLowerCase();
                            ingredient = match[4];
                        } else {
                            // Valid range: "1-2 cups"
                            isRange = true;
                            rangeOriginal = `${match[1]}-${match[2]}`;
                            quantity = rangeMode === 'low' ? q1 : rangeMode === 'high' ? q2 : (q1 + q2) / 2;
                            unit = match[3].toLowerCase();
                            ingredient = match[4];
                        }
                    }
                    // Handle mixed fraction ranges with unit
                    else if (pattern === patterns[6] || pattern === patterns[7] || pattern === patterns[8]) {
                        isRange = true;
                        let q1, q2;
                        if (pattern === patterns[6]) {
                            // "1 1/2-2 1/2 cups"
                            q1 = parseInt(match[1]) + parseQuantity(match[2]);
                            q2 = parseInt(match[3]) + parseQuantity(match[4]);
                            rangeOriginal = `${match[1]} ${match[2]}-${match[3]} ${match[4]}`;
                            unit = match[5].toLowerCase();
                            ingredient = match[6];
                        } else if (pattern === patterns[7]) {
                            // "2-2 1/2 cups"
                            q1 = parseInt(match[1]);
                            q2 = parseInt(match[2]) + parseQuantity(match[3]);
                            rangeOriginal = `${match[1]}-${match[2]} ${match[3]}`;
                            unit = match[4].toLowerCase();
                            ingredient = match[5];
                        } else {
                            // "2 1/2-3 cups"
                            q1 = parseInt(match[1]) + parseQuantity(match[2]);
                            q2 = parseInt(match[3]);
                            rangeOriginal = `${match[1]} ${match[2]}-${match[3]}`;
                            unit = match[4].toLowerCase();
                            ingredient = match[5];
                        }
                        quantity = rangeMode === 'low' ? q1 : rangeMode === 'high' ? q2 : (q1 + q2) / 2;
                    }
                    // Standalone fraction with unit: "1/4 cup honey"
                    else if (pattern === patterns[9]) {
                        quantity = parseQuantity(match[1]);
                        unit = match[2].toLowerCase();
                        ingredient = match[3];
                    }
                    // Fraction/decimal range: "1/2-3/4 cups"
                    else if (pattern === patterns[10]) {
                        const q1 = parseQuantity(match[1]);
                        const q2 = parseQuantity(match[2]);
                        isRange = true;
                        rangeOriginal = `${match[1]}-${match[2]}`;
                        quantity = rangeMode === 'low' ? q1 : rangeMode === 'high' ? q2 : (q1 + q2) / 2;
                        unit = match[3].toLowerCase();
                        ingredient = match[4];
                    }
                    // Mixed fraction count: "2 1/2 eggs"
                    else if (pattern === patterns[13]) {
                        quantity = parseUnicodeFraction(match[1]);
                        unit = match[2].toLowerCase();
                        ingredient = match[3];
                    }
                    // Standalone fraction count: "1/2 onion"
                    else if (pattern === patterns[14]) {
                        quantity = parseQuantity(match[1]);
                        ingredient = match[2];
                        
                        // Clean up ingredient (remove commas and descriptions after comma)
                        ingredient = ingredient.replace(/,.*$/, '').trim();
                        
                        // Check if this might actually be a unit-based ingredient
                        const firstWord = ingredient.split(/\s+/)[0]?.toLowerCase();
                        if (VOLUME_CONVERSIONS[firstWord] || WEIGHT_CONVERSIONS[firstWord]) {
                            // This is actually "1/2 cup something" - continue to next pattern
                            continue;
                        }
                        
                        return {
                            original: originalLine,
                            quantity,
                            unit: 'count',
                            ingredient: ingredient,
                            type: 'count',
                            baseValue: quantity,
                            isRange,
                            rangeOriginal,
                            notes,
                            alternative
                        };
                    }
                    // Handle ambiguous "2-1/2" format for count - could be range or mixed fraction
                    else if (pattern === patterns[15]) {
                        const q1 = parseInt(match[1]);
                        const q2 = parseQuantity(match[2]);
                        
                        // If q1 > q2, treat as mixed fraction (e.g., "2-1/2" = 2.5)
                        // If q1 < q2, treat as range (e.g., "1-2" = range from 1 to 2)
                        if (q1 > q2) {
                            // Mixed fraction: "2-1/2 eggs" = 2.5 eggs
                            quantity = q1 + q2;
                            ingredient = match[3];
                        } else {
                            // Valid range: "1-2 eggs"
                            isRange = true;
                            rangeOriginal = `${match[1]}-${match[2]}`;
                            quantity = rangeMode === 'low' ? q1 : rangeMode === 'high' ? q2 : (q1 + q2) / 2;
                            ingredient = match[3];
                        }
                        
                        // Clean up ingredient (remove commas and descriptions after comma)
                        ingredient = ingredient.replace(/,.*$/, '').trim();
                        
                        return {
                            original: originalLine,
                            quantity,
                            unit: 'count',
                            ingredient: ingredient,
                            type: 'count',
                            baseValue: quantity,
                            isRange,
                            rangeOriginal,
                            notes,
                            alternative
                        };
                    }
                    // Fraction/decimal range for count
                    else if (pattern === patterns[16]) {
                        const q1 = parseQuantity(match[1]);
                        const q2 = parseQuantity(match[2]);
                        isRange = true;
                        rangeOriginal = `${match[1]}-${match[2]}`;
                        quantity = rangeMode === 'low' ? q1 : rangeMode === 'high' ? q2 : (q1 + q2) / 2;
                        ingredient = match[3];
                        
                        // Clean up ingredient (remove commas and descriptions after comma)
                        ingredient = ingredient.replace(/,.*$/, '').trim();
                        
                        return {
                            original: originalLine,
                            quantity,
                            unit: 'count',
                            ingredient: ingredient,
                            type: 'count',
                            baseValue: quantity,
                            isRange,
                            rangeOriginal,
                            notes,
                            alternative
                        };
                    }
                    // Unicode fraction count: "½ onion"
                    else if (pattern === patterns[17]) {
                        quantity = parseUnicodeFraction(match[1]);
                        ingredient = match[2];
                        
                        // Clean up ingredient (remove commas and descriptions after comma)
                        ingredient = ingredient.replace(/,.*$/, '').trim();
                        
                        return {
                            original: originalLine,
                            quantity,
                            unit: 'count',
                            ingredient: ingredient,
                            type: 'count',
                            baseValue: quantity,
                            isRange,
                            rangeOriginal,
                            notes,
                            alternative
                        };
                    }
                    // Simple count: "4 chicken thighs" - LAST RESORT (most general)
                    else if (pattern === patterns[18]) {
                        quantity = parseInt(match[1]);
                        ingredient = match[2];
                        
                        // Clean up ingredient (remove commas and descriptions after comma)
                        ingredient = ingredient.replace(/,.*$/, '').trim();
                        
                        // Only treat as count if it doesn't look like it should have a unit
                        // Check if the next word after the number is a known unit
                        const firstWord = ingredient.split(/\s+/)[0]?.toLowerCase();
                        if (VOLUME_CONVERSIONS[firstWord] || WEIGHT_CONVERSIONS[firstWord]) {
                            // This is actually a unit-based ingredient, let it fall through
                            continue;
                        }
                        
                        return {
                            original: originalLine,
                            quantity,
                            unit: 'count',
                            ingredient: ingredient,
                            type: 'count',
                            baseValue: quantity,
                            isRange,
                            rangeOriginal,
                            notes,
                            alternative
                        };
                    }
                    // Simple unit-based: "2 cups flour" (patterns[12])
                    else if (pattern === patterns[12]) {
                        quantity = parseQuantity(match[1]);
                        unit = match[2].toLowerCase();
                        ingredient = match[3];
                        
                        // Check if this is a size descriptor (not a real unit)
                        const sizeDescriptors = ['small', 'medium', 'large', 'extra-large', 'jumbo', 'whole', 'fresh', 'dried', 'chopped', 'minced', 'sliced', 'diced'];
                        if (sizeDescriptors.includes(unit) || (!VOLUME_CONVERSIONS[unit] && !WEIGHT_CONVERSIONS[unit])) {
                            // Treat as count item: "2 large eggs" → quantity=2, ingredient="large eggs"
                            ingredient = match[2] + ' ' + match[3];
                            ingredient = ingredient.replace(/,.*$/, '').trim();
                            
                            return {
                                original: originalLine,
                                quantity,
                                unit: 'count',
                                ingredient: ingredient,
                                type: 'count',
                                baseValue: quantity,
                                isRange,
                                rangeOriginal,
                                notes,
                                alternative
                            };
                        }
                    }
                    // Unicode fraction with unit (patterns[13])
                    else if (pattern === patterns[13]) {
                        quantity = parseInt(match[1]);
                        unit = match[2].toLowerCase();
                        ingredient = match[3];
                    }

                    // Clean up ingredient (remove commas and descriptions after comma)
                    if (ingredient) {
                        ingredient = ingredient.replace(/,.*$/, '').trim();
                    }

                    // Determine if volume or weight
                    let type = null;
                    let baseValue = null;

                    if (unit && VOLUME_CONVERSIONS[unit]) {
                        type = 'volume';
                        baseValue = quantity * VOLUME_CONVERSIONS[unit];
                    } else if (unit && WEIGHT_CONVERSIONS[unit]) {
                        type = 'weight';
                        baseValue = quantity * WEIGHT_CONVERSIONS[unit];
                    }

                    if (type) {
                        return {
                            original: originalLine,
                            quantity,
                            unit,
                            ingredient: ingredient,
                            type,
                            baseValue,
                            isRange,
                            rangeOriginal,
                            notes,
                            alternative // Include parsed alternative if found
                        };
                    }
                }
            }

            return null; // Couldn't parse
        };

        const parseQuantity = (str) => {
            // Handle fractions like "1/2"
            if (str.includes('/')) {
                const [num, denom] = str.split('/').map(Number);
                return num / denom;
            }
            return parseFloat(str);
        };

        const parseUnicodeFraction = (str) => {
            const fractions = {
                '½': 0.5, '⅓': 0.333, '⅔': 0.667,
                '¼': 0.25, '¾': 0.75,
                '⅛': 0.125, '⅜': 0.375, '⅝': 0.625, '⅞': 0.875
            };
            return fractions[str] || 1;
        };

        /* FORMAT NUMBER WITH FRACTIONS
         * Converts decimal numbers to nice fractions for display:
         * - 0.5 → ½
         * - 0.333 → ⅓
         * - 0.667 → ⅔
         * - 0.25 → ¼
         * - 0.75 → ¾
         * - etc.
         * Also handles "pinch" for very small amounts (0 → "a")
         */
        const formatNumber = (num) => {
            // Handle special case for pinch
            if (num === 0) return 'a';
            
            // Handle whole numbers
            if (num % 1 === 0) return num.toString();
            
            // For very small non-zero numbers, round to nearest fraction
            if (num < 0.1 && num > 0) {
                // Less than 0.1, round to nearest ⅛
                const eighths = Math.round(num * 8);
                if (eighths === 1) return '⅛';
                if (eighths === 0) return '0';
            }
            
            // Try to convert to fraction if close
            const fractions = [
                [0.125, '⅛'], [0.167, '⅙'], [0.25, '¼'], [0.333, '⅓'], [0.375, '⅜'],
                [0.5, '½'], [0.625, '⅝'], [0.667, '⅔'], [0.75, '¾'], [0.833, '⅚'], [0.875, '⅞']
            ];
            
            const decimal = num % 1;
            const whole = Math.floor(num);
            
            // Check if decimal part matches a fraction
            for (const [val, frac] of fractions) {
                if (Math.abs(decimal - val) < 0.02) {
                    return whole > 0 ? `${whole} ${frac}` : frac;
                }
            }
            
            // If number is very close to a whole number (within 0.05), round it
            if (decimal < 0.05) {
                return whole.toString();
            }
            if (decimal > 0.95) {
                return (whole + 1).toString();
            }
            
            // For awkward decimals between fractions, round to nearest ¼
            const quarters = Math.round(num * 4) / 4;
            const quarterDecimal = quarters % 1;
            
            // Check if the rounded quarter matches a fraction
            for (const [val, frac] of fractions) {
                if (Math.abs(quarterDecimal - val) < 0.01) {
                    const quarterWhole = Math.floor(quarters);
                    return quarterWhole > 0 ? `${quarterWhole} ${frac}` : frac;
                }
            }
            
            // Last resort: return decimal with 2 places, removing trailing zeros
            return num.toFixed(2).replace(/\.?0+$/, '');
        };

        /* PLURALIZE UNITS
         * Intelligently pluralizes measurement units:
         * - If exactly 1: return singular (1 cup)
         * - If already plural: return as-is (cups → cups)
         * - Special cases: leaf → leaves, clove → cloves
         * - Default: add 's' (tsp → tsps)
         */
        const pluralize = (num, unit) => {
            // Round to check if singular or plural
            const roundedNum = Math.round(num * 100) / 100;
            
            // If exactly 1, use singular
            if (roundedNum === 1) return unit;
            
            // Common pluralization rules
            const lowerUnit = unit.toLowerCase();
            
            // Already plural
            if (lowerUnit.endsWith('s') || lowerUnit.endsWith('es')) return unit;
            
            // Special cases
            const specialPlurals = {
                'leaf': 'leaves',
                'clove': 'cloves',
                'bulb': 'bulbs',
                'pinch': 'pinches',
                'dash': 'dashes',
                'drop': 'drops',
                'inch': 'inches',
                'bunch': 'bunches',
                'sprig': 'sprigs',
                'stick': 'sticks',
                'cube': 'cubes',
                'rasher': 'rashers',
                'slice': 'slices',
                'piece': 'pieces',
            };
            
            if (specialPlurals[lowerUnit]) {
                return specialPlurals[lowerUnit];
            }
            
            // Default: add 's'
            return unit + 's';
        };

        // ============================================================================
        // MAIN REACT COMPONENT
        // ============================================================================
        
        function RecipeScaler() {
            // ========================================================================
            // STATE MANAGEMENT
            // ========================================================================
            
            // Input/Output state
            const [inputText, setInputText] = useState(''); // Raw pasted recipe text
            const [originalServings, setOriginalServings] = useState(1); // Recipe's original serving size (changed to 1)
            const [targetServings, setTargetServings] = useState(23); // Desired serving size (changed to 23)
            const [parsedIngredients, setParsedIngredients] = useState([]); // Array of parsed ingredient objects
            const [unparsedLines, setUnparsedLines] = useState([]); // Lines that couldn't be parsed
            
            // Display preferences
            const [useMetric, setUseMetric] = useState(false); // Toggle metric vs imperial units
            const [rangeHandling, setRangeHandling] = useState('average'); // How to handle ranges: 'low', 'average', 'high'
            const [unitOverrides, setUnitOverrides] = useState({}); // Per-ingredient unit overrides {idx: unit}
            const [cookingMode, setCookingMode] = useState(false); // Edit mode toggle (shows advanced controls)
            const [checkedIngredients, setCheckedIngredients] = useState({}); // Track checked items {idx: boolean}
            const [copySuccess, setCopySuccess] = useState(false); // Show "Copied!" feedback
            
            // Page navigation
            const [currentPage, setCurrentPage] = useState('scaler'); // 'scaler' or 'settings'
            
            // Recipe management
            const [savedRecipes, setSavedRecipes] = useState([]); // Array of saved recipes
            const [recipeName, setRecipeName] = useState(''); // Name for saving current recipe
            const [showSaved, setShowSaved] = useState(false); // Toggle saved recipes view
            
            // Custom conversions (e.g., "1 bulb = 12 cloves")
            const [customConversions, setCustomConversions] = useState({}); // {unit: {to: string, ratio: number, note: string}}
            const [newConversionFrom, setNewConversionFrom] = useState(''); // Form: unit to convert from
            const [newConversionTo, setNewConversionTo] = useState(''); // Form: unit to convert to
            const [newConversionRatio, setNewConversionRatio] = useState(''); // Form: conversion ratio
            const [newConversionNote, setNewConversionNote] = useState(''); // Form: optional note
            const [editingKey, setEditingKey] = useState(null); // Which conversion is being edited
            const [editValues, setEditValues] = useState({ to: '', ratio: '', note: '' }); // Edit form values
            
            // Display rules for how to format scaled measurements
            const [displayRules, setDisplayRules] = useState({
                noFractionalQuarts: true,    // 2.5 qt → 2 qt + 2 cups
                noFractionalGallons: true,   // 1.5 gal → 1 gal + 2 qt
                noFractionalPounds: false,   // 2.5 lb → 2 lb + 8 oz (optional)
                roundEggsUp: true,           // 2.3 eggs → 3 eggs
            });

            // Common ambiguous items that should show warnings
            const AMBIGUOUS_ITEMS = {
                // Imprecise measurements
                'pinch': { measurement: '~1/16 tsp (0.3 mL)', note: 'Amount held between thumb + forefinger' },
                'dash': { measurement: '~1/8 tsp (0.6 mL)', note: 'Often a bit more than a pinch' },
                'smidgen': { measurement: '~1/32 tsp (0.15 mL)', note: 'Half a pinch; rarely used' },
                'drop': { measurement: '~0.05 mL', note: 'A literal droplet' },
                'hint': { measurement: '~1/32–1/16 tsp', note: 'Very small flavor amount; inconsistent' },
                'sprinkle': { measurement: '1 pinch to 1 tsp', note: 'Depends heavily on ingredient' },
                'dusting': { measurement: '~1–2 tsp', note: 'Very thin layer, usually powdered sugar or cocoa' },
                'drizzle': { measurement: '1–2 tsp', note: 'Thin liquid stream' },
                'splash': { measurement: '1–2 tsp', note: 'Liquids like vinegar or wine' },
                'glug': { measurement: '1–2 tbsp', note: 'Sound-based measure, usually olive oil' },
                'handful': { measurement: '1/4 to 1 cup', note: "Depends on the cook's hand" },
                
                // Heaping/scant measurements
                'heaping': { measurement: '10–20% over level', note: 'Mounded measurement' },
                'rounded': { measurement: '~1.25x level', note: 'Similar to heaping' },
                'scant': { measurement: '10–20% under level', note: 'Slightly less than level' },
                
                // Size descriptors
                'small': { measurement: 'Varies by item', note: 'Subjective size descriptor' },
                'medium': { measurement: 'Varies by item', note: 'Subjective size descriptor' },
                'large': { measurement: 'Varies by item', note: 'Subjective size descriptor' },
                
                // Garlic
                'clove': { measurement: '3–7 g each', note: 'Garlic clove size varies significantly' },
                'cloves': { measurement: '3–7 g each', note: 'Garlic clove size varies significantly' },
                'bulb': { measurement: '10-15 cloves', note: 'Garlic bulb size varies by type' },
                'bulbs': { measurement: '10-15 cloves', note: 'Garlic bulb size varies by type' },
                'head': { measurement: '10-15 cloves', note: 'Garlic head size varies by type' },
                'heads': { measurement: '10-15 cloves', note: 'Garlic head size varies by type' },
                
                // Ginger
                'knob': { measurement: '1–2 tbsp grated (10–20 g)', note: 'Thumb-sized piece' },
                
                // Herbs
                'sprig': { measurement: '2–4 in long, ~1 tsp chopped', note: 'Size varies (thyme, rosemary, etc.)' },
                'sprigs': { measurement: '2–4 in long, ~1 tsp chopped', note: 'Size varies (thyme, rosemary, etc.)' },
                'bunch': { measurement: '1–2 oz (30–60 g)', note: 'Very inconsistent measurement' },
                'bunches': { measurement: '1–2 oz (30–60 g)', note: 'Very inconsistent measurement' },
                'leaf': { measurement: '0.5–1 g each', note: 'Size varies (basil, mint, etc.)' },
                'leaves': { measurement: '0.5–1 g each', note: 'Size varies (basil, mint, etc.)' },
                
                // Butter
                'stick': { measurement: '1/2 cup (113 g)', note: 'U.S. standard stick of butter' },
                'cube': { measurement: '1 tbsp (14 g)', note: 'Often 1 tbsp piece of butter' },
                
                // Meat cuts
                'slab': { measurement: 'No standard', note: 'Context needed for size' },
                'rasher': { measurement: '1 slice', note: 'Common in UK/Canada for bacon' },
                'fillet': { measurement: '1 whole piece', note: 'Size depends on fish/cut' },
                'filet': { measurement: '1 whole piece', note: 'Size depends on fish/cut' },
                
                // Containers
                'can': { measurement: 'Varies', note: 'Container sizes vary by brand' },
                'cans': { measurement: 'Varies', note: 'Container sizes vary by brand' },
                'jar': { measurement: 'Varies', note: 'Container sizes vary by brand' },
                'jars': { measurement: 'Varies', note: 'Container sizes vary by brand' },
            };

            // Load saved recipes from localStorage
            useEffect(() => {
                const saved = localStorage.getItem('savedRecipes');
                if (saved) {
                    setSavedRecipes(JSON.parse(saved));
                }
                
                // Load display rules
                const rules = localStorage.getItem('displayRules');
                if (rules) {
                    setDisplayRules(JSON.parse(rules));
                }
                
                const conversions = localStorage.getItem('customConversions');
                if (conversions) {
                    setCustomConversions(JSON.parse(conversions));
                } else {
                    // Set common default conversions on first load
                    const defaultConversions = {
                        // Imprecise Measurements
                        'pinch': { to: 'tsp', ratio: 0.0625, note: '~1/16 tsp, thumb + forefinger' },
                        'dash': { to: 'tsp', ratio: 0.125, note: '~1/8 tsp' },
                        'smidgen': { to: 'tsp', ratio: 0.03125, note: '~1/32 tsp, half a pinch' },
                        'drop': { to: 'ml', ratio: 0.05, note: 'Literal droplet' },
                        'hint': { to: 'tsp', ratio: 0.04, note: '~1/32-1/16 tsp, very small' },
                        'sprinkle': { to: 'tsp', ratio: 0.5, note: '1 pinch to 1 tsp, varies' },
                        'dusting': { to: 'tsp', ratio: 1.5, note: 'Thin layer, 1-2 tsp' },
                        'drizzle': { to: 'tsp', ratio: 1.5, note: 'Thin liquid stream' },
                        'splash': { to: 'tsp', ratio: 1.5, note: 'Liquids like vinegar or wine' },
                        'glug': { to: 'tbsp', ratio: 1.5, note: 'Sound-based, usually olive oil' },
                        'handful': { to: 'cup', ratio: 0.5, note: "1/4 to 1 cup, depends on hand" },
                        
                        // Modified Measurements
                        'heaping teaspoon': { to: 'tsp', ratio: 1.15, note: '10-20% over level' },
                        'heaping tablespoon': { to: 'tbsp', ratio: 1.15, note: '10-20% over level' },
                        'rounded tablespoon': { to: 'tbsp', ratio: 1.25, note: 'Similar to heaping' },
                        'scant teaspoon': { to: 'tsp', ratio: 0.85, note: '10-20% under level' },
                        'scant tablespoon': { to: 'tbsp', ratio: 0.85, note: '10-20% under level' },
                        'scant cup': { to: 'fl oz', ratio: 7.5, note: 'Just under 8 oz' },
                        
                        // Garlic
                        'garlic clove': { to: 'garlic bulbs', ratio: 0.0833, note: '12 cloves per bulb' },
                        'garlic bulb': { to: 'cloves', ratio: 12, note: '10-15 cloves typical' },
                        'garlic head': { to: 'cloves', ratio: 12, note: 'Same as bulb' },
                        'clove': { to: 'garlic bulbs', ratio: 0.0833, note: '12 cloves per bulb' },
                        
                        // Ginger
                        'knob of ginger': { to: 'tbsp grated', ratio: 1.5, note: 'Thumb-sized piece (10-20g)' },
                        'knob ginger': { to: 'tbsp grated', ratio: 1.5, note: 'Thumb-sized piece (10-20g)' },
                        
                        // Herbs
                        'sprig': { to: 'tsp chopped', ratio: 1, note: '2-4 in long (thyme, rosemary)' },
                        'bunch parsley': { to: 'oz', ratio: 1.5, note: '1-2 oz (30-60g), very inconsistent' },
                        'bunch cilantro': { to: 'oz', ratio: 1.5, note: '1-2 oz (30-60g), very inconsistent' },
                        'bunch basil': { to: 'oz', ratio: 1.5, note: '1-2 oz (30-60g), very inconsistent' },
                        'basil leaf': { to: 'g', ratio: 0.75, note: '0.5-1g each' },
                        'mint leaf': { to: 'g', ratio: 0.75, note: '0.5-1g each' },
                        
                        // Butter
                        'stick of butter': { to: 'cup', ratio: 0.5, note: 'U.S. standard (113g)' },
                        'stick butter': { to: 'tbsp', ratio: 8, note: 'U.S. standard (113g)' },
                        'cube of butter': { to: 'tbsp', ratio: 1, note: 'Often 1 tbsp piece (14g)' },
                        
                        // Meat Cuts
                        'rasher': { to: 'slice', ratio: 1, note: 'Common in UK/Canada for bacon' },
                        
                        // Common Vegetables
                        'small onion': { to: 'cup chopped', ratio: 0.75, note: 'Diced' },
                        'medium onion': { to: 'cup chopped', ratio: 1.5, note: 'Diced' },
                        'large onion': { to: 'cup chopped', ratio: 2, note: 'Diced' },
                        'small carrot': { to: 'cup chopped', ratio: 0.33, note: 'Diced' },
                        'medium carrot': { to: 'cup chopped', ratio: 0.5, note: 'Diced' },
                        'large carrot': { to: 'cup chopped', ratio: 0.75, note: 'Diced' },
                        
                        // Citrus
                        'small lemon': { to: 'tbsp juice', ratio: 2, note: 'Fresh lemon' },
                        'medium lemon': { to: 'tbsp juice', ratio: 3, note: 'Fresh lemon' },
                        'large lemon': { to: 'tbsp juice', ratio: 4, note: 'Fresh lemon' },
                        'medium lime': { to: 'tbsp juice', ratio: 2, note: 'Fresh lime' },
                        
                        // Containers
                        'can tomatoes': { to: 'oz', ratio: 14.5, note: 'Standard can size' },
                        'small can': { to: 'oz', ratio: 8, note: 'Typical small can' },
                    };
                    setCustomConversions(defaultConversions);
                    localStorage.setItem('customConversions', JSON.stringify(defaultConversions));
                }
            }, []);

            const addCustomConversion = () => {
                if (!newConversionFrom || !newConversionTo || !newConversionRatio) {
                    alert('Please fill in From, To, and Ratio fields');
                    return;
                }
                
                const ratio = parseFloat(newConversionRatio);
                if (isNaN(ratio) || ratio <= 0) {
                    alert('Ratio must be a positive number');
                    return;
                }
                
                const updated = {
                    ...customConversions,
                    [newConversionFrom.toLowerCase()]: {
                        to: newConversionTo.toLowerCase(),
                        ratio: ratio,
                        note: newConversionNote || ''
                    }
                };
                
                setCustomConversions(updated);
                localStorage.setItem('customConversions', JSON.stringify(updated));
                
                setNewConversionFrom('');
                setNewConversionTo('');
                setNewConversionRatio('');
                setNewConversionNote('');
            };
            
            const updateDisplayRule = (rule, value) => {
                const updated = { ...displayRules, [rule]: value };
                setDisplayRules(updated);
                localStorage.setItem('displayRules', JSON.stringify(updated));
            };

            const deleteCustomConversion = (key) => {
                const updated = { ...customConversions };
                delete updated[key];
                setCustomConversions(updated);
                localStorage.setItem('customConversions', JSON.stringify(updated));
            };

            const startEditing = (key, value) => {
                setEditingKey(key);
                setEditValues({ to: value.to, ratio: value.ratio, note: value.note || '' });
            };

            const saveEdit = (oldKey) => {
                const updated = { ...customConversions };
                delete updated[oldKey];
                updated[oldKey] = {
                    to: editValues.to,
                    ratio: parseFloat(editValues.ratio),
                    note: editValues.note
                };
                setCustomConversions(updated);
                localStorage.setItem('customConversions', JSON.stringify(updated));
                setEditingKey(null);
            };

            const cancelEdit = () => {
                setEditingKey(null);
                setEditValues({ to: '', ratio: '', note: '' });
            };

            const isAmbiguous = (ingredient) => {
                const lowerIngredient = ingredient.ingredient.toLowerCase();
                return Object.keys(AMBIGUOUS_ITEMS).some(item => lowerIngredient.includes(item));
            };

            const getAmbiguityWarning = (ingredient) => {
                const lower = ingredient.ingredient.toLowerCase();
                
                // Find matching ambiguous term
                for (const [term, info] of Object.entries(AMBIGUOUS_ITEMS)) {
                    if (lower.includes(term)) {
                        // Check if user has defined this conversion
                        const hasConversion = Object.keys(customConversions).some(key => 
                            lower.includes(key.toLowerCase())
                        );
                        
                        if (hasConversion) {
                            return `${info.note} (~${info.measurement})`;
                        } else {
                            return `${info.note} - Define in Settings to convert`;
                        }
                    }
                }
                
                return 'Measurement may vary - Define in Settings';
            };

            const parseInput = () => {
                const lines = inputText.split('\n');
                const ingredients = [];
                const unparsed = [];
                
                for (const line of lines) {
                    if (line.trim()) {
                        const parsed = parseIngredient(line, rangeHandling);
                        if (parsed) {
                            ingredients.push(parsed);
                        } else {
                            unparsed.push(line.trim());
                        }
                    }
                }
                
                setParsedIngredients(ingredients);
                setUnparsedLines(unparsed);
            };

            /* ====================================================================
             * SCALE INGREDIENT
             * ====================================================================
             * Core scaling logic with smart custom conversion handling
             * 
             * Process:
             * 1. Calculate scale factor (target / original servings)
             * 2. Scale the quantity
             * 3. Check for custom conversions (e.g., bulbs ⇄ cloves)
             * 4. Apply smart display logic:
             *    - If scaled < 1 of original unit → show in smaller unit (½ bulb → 6 cloves)
             *    - If scaled >= 1 → show in original unit with conversion in parentheses
             * 5. For standard units, use smart conversion (smartConvertVolume/Weight)
             * 6. Apply any user overrides from dropdown
             * 
             * Returns: {value, unit, converted, originalUnit, originalScaledValue}
             */
            const scaleIngredient = (ingredient, idx) => {
                // "To taste" items don't scale
                if (ingredient.type === 'seasoning') {
                    return { value: '', unit: 'to taste' };
                }
                
                // Handle empty servings values
                const origServings = originalServings === '' || originalServings <= 0 ? 1 : originalServings;
                const targServings = targetServings === '' || targetServings <= 0 ? 1 : targetServings;
                
                const scaleFactor = targServings / origServings;
                const scaledQuantity = ingredient.quantity * scaleFactor;
                
                // Check if this ingredient matches a custom conversion
                const lowerIngredient = ingredient.ingredient.toLowerCase();
                const lowerUnit = ingredient.unit.toLowerCase();
                
                // Try to find a matching conversion
                let matchedConversion = null;
                let bestMatchLength = 0;
                
                for (const [key, conversion] of Object.entries(customConversions)) {
                    const lowerKey = key.toLowerCase();
                    
                    // Build possible match strings
                    const unitIngredient = `${lowerUnit} ${lowerIngredient}`;
                    const ingredientUnit = `${lowerIngredient} ${lowerUnit}`;
                    
                    // Check various matching possibilities (prefer longer/more specific matches)
                    if (unitIngredient.includes(lowerKey) || 
                        ingredientUnit.includes(lowerKey) ||
                        lowerIngredient.includes(lowerKey) ||
                        lowerUnit === lowerKey) {
                        // Prefer longer matches (more specific)
                        if (lowerKey.length > bestMatchLength) {
                            matchedConversion = { key, ...conversion };
                            bestMatchLength = lowerKey.length;
                        }
                    }
                }
                
                // If we found a conversion, use it
                if (matchedConversion) {
                    const convertedValue = scaledQuantity * matchedConversion.ratio;
                    
                    // If the scaled quantity is less than 1 of the original unit, 
                    // show in the converted (smaller) unit instead
                    // e.g., "½ bulb" should show as "6 cloves" not "½ bulb"
                    if (scaledQuantity < 1) {
                        return { 
                            value: convertedValue, 
                            unit: matchedConversion.to,
                            converted: false, // This is now the primary display
                            originalUnit: ingredient.unit,
                            originalScaledValue: null, // Don't show the fractional original
                            conversionKey: matchedConversion.key
                        };
                    }
                    
                    // For >= 1 of the original unit, keep showing in original with conversion in parentheses
                    return { 
                        value: scaledQuantity, 
                        unit: ingredient.unit,
                        converted: true, // Show the conversion in parentheses
                        originalUnit: matchedConversion.to,
                        originalScaledValue: convertedValue,
                        conversionKey: matchedConversion.key
                    };
                }
                
                const scaledBaseValue = ingredient.baseValue * scaleFactor;
                
                // Check if there's a unit override for this ingredient
                const overrideUnit = unitOverrides[idx];
                
                if (ingredient.type === 'volume') {
                    if (overrideUnit) {
                        // Convert to specific unit
                        const conversionFactor = VOLUME_CONVERSIONS[overrideUnit];
                        return { value: scaledBaseValue / conversionFactor, unit: overrideUnit };
                    }
                    return smartConvertVolume(scaledBaseValue, useMetric, ingredient.ingredient, displayRules);
                } else if (ingredient.type === 'weight') {
                    if (overrideUnit) {
                        // Convert to specific unit
                        const conversionFactor = WEIGHT_CONVERSIONS[overrideUnit];
                        return { value: scaledBaseValue / conversionFactor, unit: overrideUnit };
                    }
                    return smartConvertWeight(scaledBaseValue, useMetric, ingredient.ingredient, displayRules);
                } else if (ingredient.type === 'count') {
                    // For count items, just scale the number
                    let value = scaledBaseValue;
                    
                    // Apply roundEggsUp rule for eggs
                    if (displayRules.roundEggsUp && ingredient.ingredient.toLowerCase().includes('egg')) {
                        const decimal = value % 1;
                        if (decimal > 0.25) {
                            value = Math.ceil(value);
                        } else if (decimal > 0) {
                            value = Math.floor(value);
                        }
                    }
                    
                    return { value: value, unit: '' };
                }
            };

            /* ====================================================================
             * SCALE ALTERNATIVE INGREDIENT
             * ====================================================================
             * Scales the alternative ingredient from parentheses (e.g., "or 4 thighs")
             * Uses the same scaling logic as the main ingredient
             */
            const scaleAlternative = (alternative, scaleFactor) => {
                if (!alternative) return null;
                
                const scaledQuantity = alternative.quantity * scaleFactor;
                
                // Use the same conversion logic based on type
                if (alternative.type === 'volume') {
                    const scaledBaseValue = alternative.baseValue * scaleFactor;
                    return smartConvertVolume(scaledBaseValue, useMetric, alternative.ingredient || '', displayRules);
                } else if (alternative.type === 'weight') {
                    const scaledBaseValue = alternative.baseValue * scaleFactor;
                    return smartConvertWeight(scaledBaseValue, useMetric, alternative.ingredient || '', displayRules);
                } else if (alternative.type === 'count') {
                    return { value: scaledQuantity, unit: '' };
                } else {
                    // Fallback for unparsed alternatives - just scale the quantity
                    return { value: scaledQuantity, unit: alternative.unit };
                }
            };

            const getUnitOptions = (ingredient) => {
                if (ingredient.type === 'volume') {
                    if (useMetric) {
                        return ['ml', 'l'];
                    } else {
                        return ['tsp', 'tbsp', 'fl oz', 'cup', 'pt', 'qt', 'gal'];
                    }
                } else if (ingredient.type === 'weight') {
                    if (useMetric) {
                        return ['g', 'kg'];
                    } else {
                        return ['oz', 'lb'];
                    }
                }
                return [];
            };

            const setUnitOverride = (idx, unit) => {
                setUnitOverrides(prev => ({
                    ...prev,
                    [idx]: unit
                }));
            };

            const toggleIngredientChecked = (idx) => {
                setCheckedIngredients(prev => ({
                    ...prev,
                    [idx]: !prev[idx]
                }));
            };

            const copyToClipboard = () => {
                if (parsedIngredients.length === 0) return;
                
                // Helper function to convert numbers to plain text fractions (not unicode)
                const toPlainFraction = (num) => {
                    if (num === 0) return 'a pinch of';
                    if (num % 1 === 0) return num.toString();
                    
                    const decimal = num % 1;
                    const whole = Math.floor(num);
                    
                    // Map decimals to plain text fractions
                    const fractionMap = [
                        [0.125, '1/8'],
                        [0.167, '1/6'], 
                        [0.25, '1/4'],
                        [0.333, '1/3'],
                        [0.375, '3/8'],
                        [0.5, '1/2'],
                        [0.625, '5/8'],
                        [0.667, '2/3'],
                        [0.75, '3/4'],
                        [0.833, '5/6'],
                        [0.875, '7/8']
                    ];
                    
                    // Check for exact or close matches
                    for (const [val, frac] of fractionMap) {
                        if (Math.abs(decimal - val) < 0.02) {
                            return whole > 0 ? `${whole} ${frac}` : frac;
                        }
                    }
                    
                    // Round to nearest quarter for awkward decimals
                    const quarters = Math.round(num * 4) / 4;
                    const quarterDecimal = quarters % 1;
                    
                    for (const [val, frac] of fractionMap) {
                        if (Math.abs(quarterDecimal - val) < 0.01) {
                            const quarterWhole = Math.floor(quarters);
                            return quarterWhole > 0 ? `${quarterWhole} ${frac}` : frac;
                        }
                    }
                    
                    // Last resort: decimal
                    return num.toFixed(2).replace(/\.?0+$/, '');
                };
                
                const scaleFactor = (targetServings || 1) / (originalServings || 1);
                let text = `Recipe (${targetServings} servings)\n\n`;
                
                parsedIngredients.forEach((ingredient, idx) => {
                    const scaled = scaleIngredient(ingredient, idx);
                    let amount;
                    
                    // Handle compound measurements
                    if (scaled.remainder && scaled.remainderUnit) {
                        const mainUnit = pluralize(scaled.value, scaled.unit);
                        const remainderUnit = pluralize(scaled.remainder, scaled.remainderUnit);
                        amount = `${toPlainFraction(scaled.value)} ${mainUnit} ${toPlainFraction(scaled.remainder)} ${remainderUnit}`;
                    } 
                    // Handle count items (no unit to display)
                    else if (scaled.unit === 'count' || scaled.unit === '') {
                        amount = toPlainFraction(scaled.value);
                    }
                    // Handle regular measurements with units
                    else {
                        const unitText = pluralize(scaled.value, scaled.unit);
                        amount = `${toPlainFraction(scaled.value)} ${unitText}`;
                    }
                    
                    let line = `${amount} ${ingredient.ingredient}`;
                    
                    // Add scaled alternative if present
                    if (ingredient.alternative) {
                        const scaledAlt = scaleAlternative(ingredient.alternative, scaleFactor);
                        if (scaledAlt) {
                            let altAmount;
                            if (scaledAlt.remainder && scaledAlt.remainderUnit) {
                                const mainUnit = pluralize(scaledAlt.value, scaledAlt.unit);
                                const remainderUnit = pluralize(scaledAlt.remainder, scaledAlt.remainderUnit);
                                altAmount = `${toPlainFraction(scaledAlt.value)} ${mainUnit} ${toPlainFraction(scaledAlt.remainder)} ${remainderUnit}`;
                            } else if (scaledAlt.unit === 'count' || scaledAlt.unit === '') {
                                altAmount = toPlainFraction(scaledAlt.value);
                            } else {
                                const unitText = pluralize(scaledAlt.value, scaledAlt.unit);
                                altAmount = `${toPlainFraction(scaledAlt.value)} ${unitText}`;
                            }
                            line += ` (or ${altAmount} ${ingredient.alternative.ingredient})`;
                        }
                    }
                    
                    text += `${line}\n`;
                });
                
                navigator.clipboard.writeText(text).then(() => {
                    setCopySuccess(true);
                    setTimeout(() => setCopySuccess(false), 2000);
                }).catch(err => {
                    console.error('Failed to copy:', err);
                });
            };

            const saveRecipe = () => {
                if (!recipeName.trim()) {
                    alert('Please enter a recipe name');
                    return;
                }
                
                const recipe = {
                    id: Date.now(),
                    name: recipeName,
                    servings: originalServings,
                    ingredients: inputText,
                    date: new Date().toISOString()
                };
                
                const updated = [...savedRecipes, recipe];
                setSavedRecipes(updated);
                localStorage.setItem('savedRecipes', JSON.stringify(updated));
                setRecipeName('');
                alert('Recipe saved!');
            };

            const loadRecipe = (recipe) => {
                setInputText(recipe.ingredients);
                setOriginalServings(recipe.servings);
                setTargetServings(recipe.servings);
                setShowSaved(false);
                parseInput();
            };

            const deleteRecipe = (id) => {
                const updated = savedRecipes.filter(r => r.id !== id);
                setSavedRecipes(updated);
                localStorage.setItem('savedRecipes', JSON.stringify(updated));
            };

            useEffect(() => {
                if (inputText) {
                    parseInput();
                }
            }, [inputText, rangeHandling]);

            return (
                <div className="min-h-screen bg-gray-900 p-4">
                    <div className="max-w-6xl mx-auto">
                        {/* Header with Navigation */}
                        <div className="bg-gray-800 rounded-lg shadow-xl p-4 md:p-6 mb-6">
                            <div className="flex justify-between items-center">
                                <div>
                                    <h1 className="text-2xl md:text-3xl font-bold text-green-400 mb-1 md:mb-2">Smart Recipe Scaler</h1>
                                    <p className="text-sm md:text-base text-gray-400 hidden sm:block">Scale recipes with intelligent unit conversions</p>
                                </div>
                                
                                {/* Navigation - visible on all screen sizes */}
                                <div className="flex gap-2">
                                    <button
                                        onClick={() => setCurrentPage('scaler')}
                                        className={`px-4 md:px-6 py-2 rounded font-semibold text-sm md:text-base ${
                                            currentPage === 'scaler'
                                                ? 'bg-green-600 text-white'
                                                : 'bg-gray-700 text-gray-300 hover:bg-gray-600'
                                        }`}
                                    >
                                        Recipe Scaler
                                    </button>
                                    <button
                                        onClick={() => setCurrentPage('settings')}
                                        className={`px-4 md:px-6 py-2 rounded font-semibold text-sm md:text-base ${
                                            currentPage === 'settings'
                                                ? 'bg-green-600 text-white'
                                                : 'bg-gray-700 text-gray-300 hover:bg-gray-600'
                                        }`}
                                    >
                                        Conversion Preferences
                                    </button>
                                </div>
                            </div>
                        </div>

                        {/* Conversion Preferences Page */}
                        {currentPage === 'settings' && (
                            <div className="bg-gray-800 rounded-lg shadow-xl p-6">
                                <h2 className="text-2xl font-bold text-green-400 mb-6">Conversion Preferences</h2>
                                
                                {/* Custom Conversions Section */}
                                <div className="mb-8">
                                    <h3 className="text-xl font-bold text-green-400 mb-3">Custom Conversions</h3>
                                    <p className="text-gray-400 mb-4">
                                        Define bidirectional conversions for ambiguous measurements. Once set, conversions work automatically in both directions. 
                                        For example, defining "1 garlic bulb ⇄ 10 cloves" lets you convert bulbs to cloves OR cloves to bulbs.
                                    </p>
                                    
                                    <div className="bg-gray-700 p-6 rounded-lg mb-4">
                                        <h4 className="font-semibold text-gray-200 mb-3">Add New Conversion</h4>
                                        <div className="grid grid-cols-1 md:grid-cols-5 gap-3">
                                            <div>
                                                <label className="block text-sm text-gray-400 mb-1">Unit A</label>
                                                <input
                                                    type="text"
                                                    value={newConversionFrom}
                                                    onChange={(e) => setNewConversionFrom(e.target.value)}
                                                    placeholder="e.g., garlic bulb"
                                                    className="w-full bg-gray-600 text-gray-100 p-2 rounded border border-gray-500 focus:border-green-400 focus:outline-none"
                                                />
                                            </div>
                                            <div>
                                                <label className="block text-sm text-gray-400 mb-1">Unit B</label>
                                                <input
                                                    type="text"
                                                    value={newConversionTo}
                                                    onChange={(e) => setNewConversionTo(e.target.value)}
                                                    placeholder="e.g., cloves"
                                                    className="w-full bg-gray-600 text-gray-100 p-2 rounded border border-gray-500 focus:border-green-400 focus:outline-none"
                                                />
                                            </div>
                                            <div>
                                                <label className="block text-sm text-gray-400 mb-1">Ratio</label>
                                                <input
                                                    type="number"
                                                    value={newConversionRatio}
                                                    onChange={(e) => setNewConversionRatio(e.target.value)}
                                                    placeholder="e.g., 10"
                                                    step="0.1"
                                                    className="w-full bg-gray-600 text-gray-100 p-2 rounded border border-gray-500 focus:border-green-400 focus:outline-none"
                                                />
                                            </div>
                                            <div>
                                                <label className="block text-sm text-gray-400 mb-1">Note (Optional)</label>
                                                <input
                                                    type="text"
                                                    value={newConversionNote}
                                                    onChange={(e) => setNewConversionNote(e.target.value)}
                                                    placeholder="e.g., Varies by size"
                                                    className="w-full bg-gray-600 text-gray-100 p-2 rounded border border-gray-500 focus:border-green-400 focus:outline-none"
                                                />
                                            </div>
                                            <div className="flex items-end">
                                                <button
                                                    onClick={addCustomConversion}
                                                    className="w-full px-4 py-2 bg-green-600 hover:bg-green-700 rounded font-semibold"
                                                >
                                                    Add Conversion
                                                </button>
                                            </div>
                                        </div>
                                        <p className="text-xs text-gray-500 mt-2">
                                            Example: 1 "garlic bulb" ⇄ 10 "cloves" means enter bulb as Unit A, cloves as Unit B, ratio 10. Works both ways automatically.
                                        </p>
                                    </div>
                                    
                                    {/* Existing Conversions */}
                                    <div className="bg-gray-700 p-6 rounded-lg">
                                        <div className="flex justify-between items-center mb-3">
                                            <h4 className="font-semibold text-gray-200">Your Conversions</h4>
                                            <button
                                                onClick={() => {
                                                    if (confirm('Load default conversions? This will add common measurements (existing conversions will be kept).')) {
                                                        const defaultConversions = {
                                                            // Imprecise Measurements
                                                            'pinch': { to: 'tsp', ratio: 0.0625, note: '~1/16 tsp, thumb + forefinger' },
                                                            'dash': { to: 'tsp', ratio: 0.125, note: '~1/8 tsp' },
                                                            'smidgen': { to: 'tsp', ratio: 0.03125, note: '~1/32 tsp, half a pinch' },
                                                            'drop': { to: 'ml', ratio: 0.05, note: 'Literal droplet' },
                                                            'hint': { to: 'tsp', ratio: 0.04, note: '~1/32-1/16 tsp, very small' },
                                                            'sprinkle': { to: 'tsp', ratio: 0.5, note: '1 pinch to 1 tsp, varies' },
                                                            'dusting': { to: 'tsp', ratio: 1.5, note: 'Thin layer, 1-2 tsp' },
                                                            'drizzle': { to: 'tsp', ratio: 1.5, note: 'Thin liquid stream' },
                                                            'splash': { to: 'tsp', ratio: 1.5, note: 'Liquids like vinegar or wine' },
                                                            'glug': { to: 'tbsp', ratio: 1.5, note: 'Sound-based, usually olive oil' },
                                                            'handful': { to: 'cup', ratio: 0.5, note: "1/4 to 1 cup, depends on hand" },
                                                            'heaping teaspoon': { to: 'tsp', ratio: 1.15, note: '10-20% over level' },
                                                            'heaping tablespoon': { to: 'tbsp', ratio: 1.15, note: '10-20% over level' },
                                                            'rounded tablespoon': { to: 'tbsp', ratio: 1.25, note: 'Similar to heaping' },
                                                            'scant teaspoon': { to: 'tsp', ratio: 0.85, note: '10-20% under level' },
                                                            'scant tablespoon': { to: 'tbsp', ratio: 0.85, note: '10-20% under level' },
                                                            'scant cup': { to: 'fl oz', ratio: 7.5, note: 'Just under 8 oz' },
                                                            'garlic clove': { to: 'g', ratio: 5, note: '3-7g each, varies by size' },
                                                            'garlic bulb': { to: 'cloves', ratio: 12, note: '10-15 cloves typical' },
                                                            'garlic head': { to: 'cloves', ratio: 12, note: 'Same as bulb' },
                                                            'knob of ginger': { to: 'tbsp grated', ratio: 1.5, note: 'Thumb-sized piece (10-20g)' },
                                                            'knob ginger': { to: 'tbsp grated', ratio: 1.5, note: 'Thumb-sized piece (10-20g)' },
                                                            'sprig': { to: 'tsp chopped', ratio: 1, note: '2-4 in long (thyme, rosemary)' },
                                                            'bunch parsley': { to: 'oz', ratio: 1.5, note: '1-2 oz (30-60g), very inconsistent' },
                                                            'bunch cilantro': { to: 'oz', ratio: 1.5, note: '1-2 oz (30-60g), very inconsistent' },
                                                            'bunch basil': { to: 'oz', ratio: 1.5, note: '1-2 oz (30-60g), very inconsistent' },
                                                            'basil leaf': { to: 'g', ratio: 0.75, note: '0.5-1g each' },
                                                            'mint leaf': { to: 'g', ratio: 0.75, note: '0.5-1g each' },
                                                            'stick of butter': { to: 'cup', ratio: 0.5, note: 'U.S. standard (113g)' },
                                                            'stick butter': { to: 'tbsp', ratio: 8, note: 'U.S. standard (113g)' },
                                                            'cube of butter': { to: 'tbsp', ratio: 1, note: 'Often 1 tbsp piece (14g)' },
                                                            'rasher': { to: 'slice', ratio: 1, note: 'Common in UK/Canada for bacon' },
                                                            'small onion': { to: 'cup chopped', ratio: 0.75, note: 'Diced' },
                                                            'medium onion': { to: 'cup chopped', ratio: 1.5, note: 'Diced' },
                                                            'large onion': { to: 'cup chopped', ratio: 2, note: 'Diced' },
                                                            'small carrot': { to: 'cup chopped', ratio: 0.33, note: 'Diced' },
                                                            'medium carrot': { to: 'cup chopped', ratio: 0.5, note: 'Diced' },
                                                            'large carrot': { to: 'cup chopped', ratio: 0.75, note: 'Diced' },
                                                            'small lemon': { to: 'tbsp juice', ratio: 2, note: 'Fresh lemon' },
                                                            'medium lemon': { to: 'tbsp juice', ratio: 3, note: 'Fresh lemon' },
                                                            'large lemon': { to: 'tbsp juice', ratio: 4, note: 'Fresh lemon' },
                                                            'medium lime': { to: 'tbsp juice', ratio: 2, note: 'Fresh lime' },
                                                            'can tomatoes': { to: 'oz', ratio: 14.5, note: 'Standard can size' },
                                                            'small can': { to: 'oz', ratio: 8, note: 'Typical small can' },
                                                        };
                                                        const merged = { ...customConversions, ...defaultConversions };
                                                        setCustomConversions(merged);
                                                        localStorage.setItem('customConversions', JSON.stringify(merged));
                                                    }
                                                }}
                                                className="px-3 py-1 bg-blue-600 hover:bg-blue-700 rounded text-sm"
                                            >
                                                Load Defaults
                                            </button>
                                        </div>
                                        {Object.keys(customConversions).length > 0 ? (
                                            <div className="overflow-x-auto">
                                                <table className="w-full text-sm">
                                                    <thead>
                                                        <tr className="border-b border-gray-500">
                                                            <th className="text-left p-2 text-gray-400">Unit A</th>
                                                            <th className="text-left p-2 text-gray-400">Ratio</th>
                                                            <th className="text-left p-2 text-gray-400">Unit B</th>
                                                            <th className="text-left p-2 text-gray-400">Note</th>
                                                            <th className="text-right p-2 text-gray-400">Actions</th>
                                                        </tr>
                                                    </thead>
                                                    <tbody>
                                                        {Object.entries(customConversions).map(([key, value]) => (
                                                            <tr key={key} className="border-b border-gray-600 hover:bg-gray-600">
                                                                {editingKey === key ? (
                                                                    <>
                                                                        <td className="p-2">
                                                                            <span className="text-green-400 font-semibold">{key}</span>
                                                                        </td>
                                                                        <td className="p-2">
                                                                            <input
                                                                                type="number"
                                                                                value={editValues.ratio}
                                                                                onChange={(e) => setEditValues({...editValues, ratio: e.target.value})}
                                                                                className="w-20 bg-gray-800 text-gray-100 p-1 rounded border border-gray-500 text-sm"
                                                                                step="0.01"
                                                                            />
                                                                        </td>
                                                                        <td className="p-2">
                                                                            <input
                                                                                type="text"
                                                                                value={editValues.to}
                                                                                onChange={(e) => setEditValues({...editValues, to: e.target.value})}
                                                                                className="w-full bg-gray-800 text-gray-100 p-1 rounded border border-gray-500 text-sm"
                                                                            />
                                                                        </td>
                                                                        <td className="p-2">
                                                                            <input
                                                                                type="text"
                                                                                value={editValues.note}
                                                                                onChange={(e) => setEditValues({...editValues, note: e.target.value})}
                                                                                className="w-full bg-gray-800 text-gray-100 p-1 rounded border border-gray-500 text-sm"
                                                                            />
                                                                        </td>
                                                                        <td className="p-2 text-right">
                                                                            <button
                                                                                onClick={() => saveEdit(key)}
                                                                                className="px-2 py-1 bg-green-600 hover:bg-green-700 rounded text-xs mr-1"
                                                                            >
                                                                                Save
                                                                            </button>
                                                                            <button
                                                                                onClick={cancelEdit}
                                                                                className="px-2 py-1 bg-gray-600 hover:bg-gray-500 rounded text-xs"
                                                                            >
                                                                                Cancel
                                                                            </button>
                                                                        </td>
                                                                    </>
                                                                ) : (
                                                                    <>
                                                                        <td className="p-2">
                                                                            <span className="text-green-400 font-semibold">{key}</span>
                                                                        </td>
                                                                        <td className="p-2">{value.ratio}</td>
                                                                        <td className="p-2">
                                                                            <span className="text-green-400 font-semibold">{value.to}</span>
                                                                        </td>
                                                                        <td className="p-2 text-gray-400 text-xs">{value.note}</td>
                                                                        <td className="p-2 text-right whitespace-nowrap">
                                                                            <button
                                                                                onClick={() => startEditing(key, value)}
                                                                                className="px-2 py-1 bg-blue-600 hover:bg-blue-700 rounded text-xs mr-1"
                                                                            >
                                                                                Edit
                                                                            </button>
                                                                            <button
                                                                                onClick={() => deleteCustomConversion(key)}
                                                                                className="px-2 py-1 bg-red-600 hover:bg-red-700 rounded text-xs"
                                                                            >
                                                                                Del
                                                                            </button>
                                                                        </td>
                                                                    </>
                                                                )}
                                                            </tr>
                                                        ))}
                                                    </tbody>
                                                </table>
                                            </div>
                                        ) : (
                                            <p className="text-gray-500 italic text-center py-8">
                                                No custom conversions yet. Add conversions above to handle ambiguous measurements like "1 garlic bulb", "1 pinch salt", or "1 medium onion".
                                                <br/><br/>
                                                When you paste recipes with these terms, the app will warn you they're ambiguous and prompt you to define them here.
                                            </p>
                                        )}
                                    </div>
                                </div>
                                
                                {/* Display Rules Section */}
                                <div className="mb-8">
                                    <h3 className="text-xl font-bold text-green-400 mb-3">Display Rules</h3>
                                    <p className="text-gray-400 mb-4">
                                        Control how scaled measurements are formatted. These rules help keep outputs practical for kitchen use.
                                    </p>
                                    
                                    <div className="bg-gray-700 p-6 rounded-lg space-y-4">
                                        <label className="flex items-center gap-3 cursor-pointer">
                                            <input
                                                type="checkbox"
                                                checked={displayRules.noFractionalQuarts}
                                                onChange={(e) => updateDisplayRule('noFractionalQuarts', e.target.checked)}
                                                className="w-5 h-5 rounded bg-gray-600 border-gray-500 text-green-500 focus:ring-green-400"
                                            />
                                            <div>
                                                <span className="text-gray-200 font-medium">No fractional quarts</span>
                                                <p className="text-gray-400 text-sm">Show "2 qt + 2 cups" instead of "2½ qt"</p>
                                            </div>
                                        </label>
                                        
                                        <label className="flex items-center gap-3 cursor-pointer">
                                            <input
                                                type="checkbox"
                                                checked={displayRules.noFractionalGallons}
                                                onChange={(e) => updateDisplayRule('noFractionalGallons', e.target.checked)}
                                                className="w-5 h-5 rounded bg-gray-600 border-gray-500 text-green-500 focus:ring-green-400"
                                            />
                                            <div>
                                                <span className="text-gray-200 font-medium">No fractional gallons</span>
                                                <p className="text-gray-400 text-sm">Show "1 gal + 2 qt" instead of "1½ gal"</p>
                                            </div>
                                        </label>
                                        
                                        <label className="flex items-center gap-3 cursor-pointer">
                                            <input
                                                type="checkbox"
                                                checked={displayRules.noFractionalPounds}
                                                onChange={(e) => updateDisplayRule('noFractionalPounds', e.target.checked)}
                                                className="w-5 h-5 rounded bg-gray-600 border-gray-500 text-green-500 focus:ring-green-400"
                                            />
                                            <div>
                                                <span className="text-gray-200 font-medium">No fractional pounds</span>
                                                <p className="text-gray-400 text-sm">Show "2 lb + 8 oz" instead of "2½ lb"</p>
                                            </div>
                                        </label>
                                        
                                        <label className="flex items-center gap-3 cursor-pointer">
                                            <input
                                                type="checkbox"
                                                checked={displayRules.roundEggsUp}
                                                onChange={(e) => updateDisplayRule('roundEggsUp', e.target.checked)}
                                                className="w-5 h-5 rounded bg-gray-600 border-gray-500 text-green-500 focus:ring-green-400"
                                            />
                                            <div>
                                                <span className="text-gray-200 font-medium">Round eggs up</span>
                                                <p className="text-gray-400 text-sm">Show "3 eggs" instead of "2.3 eggs" (rounds up when &gt; 0.25)</p>
                                            </div>
                                        </label>
                                    </div>
                                </div>
                                
                                {/* Common Examples Section */}
                                <div className="bg-gray-700 p-6 rounded-lg">
                                    <h4 className="font-semibold text-gray-200 mb-3">💡 Common Conversion Examples</h4>
                                    <div className="grid grid-cols-1 md:grid-cols-2 gap-3 text-sm text-gray-300">
                                        <div>• 1 garlic bulb ⇄ 10-12 cloves</div>
                                        <div>• 1 medium onion ⇄ 1.5 cups chopped</div>
                                        <div>• 1 large onion ⇄ 2 cups chopped</div>
                                        <div>• 1 bunch parsley ⇄ 1 cup chopped</div>
                                        <div>• 1 medium lemon ⇄ 3 tbsp juice</div>
                                        <div>• 1 can tomatoes ⇄ 14.5 oz</div>
                                        <div>• 1 bunch basil ⇄ 0.5 cup chopped</div>
                                        <div>• 1 medium carrot ⇄ 0.5 cup chopped</div>
                                    </div>
                                </div>
                            </div>
                        )}

                        {/* Recipe Scaler Page */}
                        {currentPage === 'scaler' && (
                            <>
                            <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
                            {/* Input Section */}
                            <div className="bg-gray-800 rounded-lg shadow-xl p-6">
                                <div className="flex justify-between items-center mb-4">
                                    <h2 className="text-xl font-bold text-green-400">Input</h2>
                                    <button
                                        onClick={() => setShowSaved(!showSaved)}
                                        className="px-3 py-1 bg-blue-600 hover:bg-blue-700 rounded text-sm"
                                    >
                                        {showSaved ? 'Hide' : 'Saved Recipes'}
                                    </button>
                                </div>

                                {showSaved && (
                                    <div className="mb-4 p-4 bg-gray-700 rounded max-h-64 overflow-y-auto">
                                        <p className="text-xs text-yellow-400/80 mb-3">⚠ Saved locally in browser — clears if you clear site data</p>
                                        {savedRecipes.length === 0 ? (
                                            <p className="text-gray-400">No saved recipes</p>
                                        ) : (
                                            savedRecipes.map(recipe => (
                                                <div key={recipe.id} className="mb-2 p-2 bg-gray-600 rounded flex justify-between items-center">
                                                    <div>
                                                        <div className="font-bold">{recipe.name}</div>
                                                        <div className="text-sm text-gray-400">{recipe.servings} servings</div>
                                                    </div>
                                                    <div className="flex gap-2">
                                                        <button
                                                            onClick={() => loadRecipe(recipe)}
                                                            className="px-2 py-1 bg-green-600 hover:bg-green-700 rounded text-sm"
                                                        >
                                                            Load
                                                        </button>
                                                        <button
                                                            onClick={() => deleteRecipe(recipe.id)}
                                                            className="px-2 py-1 bg-red-600 hover:bg-red-700 rounded text-sm"
                                                        >
                                                            Delete
                                                        </button>
                                                    </div>
                                                </div>
                                            ))
                                        )}
                                    </div>
                                )}

                                <div className="flex justify-between items-center mb-2">
                                    <label className="block text-sm text-gray-400">Paste ingredients here</label>
                                    {inputText && (
                                        <button
                                            onClick={() => {
                                                setInputText('');
                                                setParsedIngredients([]);
                                                setUnparsedLines([]);
                                                setUnitOverrides({});
                                            }}
                                            className="px-3 py-1 bg-red-600 hover:bg-red-700 rounded text-sm"
                                        >
                                            Clear Input
                                        </button>
                                    )}
                                </div>

                                <textarea
                                    value={inputText}
                                    onChange={(e) => setInputText(e.target.value)}
                                    placeholder="Paste ingredients here... (e.g., 2 cups flour, 1/2 tsp salt, 250g sugar)"
                                    className="w-full h-64 bg-gray-700 text-gray-100 p-3 rounded border border-gray-600 focus:border-green-400 focus:outline-none font-mono text-sm"
                                />

                                <div className="mt-4 grid grid-cols-2 gap-4">
                                    <div>
                                        <label className="block text-sm text-gray-400 mb-1">Original Servings</label>
                                        <input
                                            type="number"
                                            value={originalServings}
                                            onChange={(e) => setOriginalServings(e.target.value === '' ? '' : Number(e.target.value))}
                                            min="1"
                                            className="w-full bg-gray-700 text-gray-100 p-2 rounded border border-gray-600 focus:border-green-400 focus:outline-none"
                                        />
                                    </div>
                                    <div>
                                        <label className="block text-sm text-gray-400 mb-1">Target Servings</label>
                                        <input
                                            type="number"
                                            value={targetServings}
                                            onChange={(e) => setTargetServings(e.target.value === '' ? '' : Number(e.target.value))}
                                            min="1"
                                            className="w-full bg-gray-700 text-gray-100 p-2 rounded border border-gray-600 focus:border-green-400 focus:outline-none"
                                        />
                                    </div>
                                </div>

                                <div className="mt-4 flex flex-col sm:flex-row sm:items-center sm:justify-between gap-3">
                                    <label className="flex items-center cursor-pointer">
                                        <input
                                            type="checkbox"
                                            checked={useMetric}
                                            onChange={(e) => setUseMetric(e.target.checked)}
                                            className="mr-2"
                                        />
                                        <span className="text-sm text-gray-400">Use Metric Units</span>
                                    </label>
                                    
                                    <div className="flex flex-col gap-1">
                                        <div className="flex items-center gap-2">
                                            <span className="text-sm text-gray-400">When recipe says "1-2 cups":</span>
                                            <select
                                                value={rangeHandling}
                                                onChange={(e) => setRangeHandling(e.target.value)}
                                                className="bg-gray-700 text-gray-100 px-2 py-1 rounded border border-gray-600 focus:border-green-400 focus:outline-none text-sm"
                                            >
                                                <option value="low">Use 1 (low)</option>
                                                <option value="average">Use 1.5 (average)</option>
                                                <option value="high">Use 2 (high)</option>
                                            </select>
                                        </div>
                                    </div>
                                </div>

                                <div className="mt-4 flex gap-2">
                                    <input
                                        type="text"
                                        value={recipeName}
                                        onChange={(e) => setRecipeName(e.target.value)}
                                        placeholder="Recipe name"
                                        className="flex-1 bg-gray-700 text-gray-100 p-2 rounded border border-gray-600 focus:border-green-400 focus:outline-none"
                                    />
                                    <button
                                        onClick={saveRecipe}
                                        className="px-4 py-2 bg-green-600 hover:bg-green-700 rounded font-semibold"
                                    >
                                        Save Recipe
                                    </button>
                                </div>
                            </div>

                            {/* Output Section */}
                            <div className="bg-gray-800 rounded-lg shadow-xl p-4 sm:p-6">
                                <div className="flex flex-col sm:flex-row sm:justify-between sm:items-center gap-3 mb-6">
                                    <h2 className="text-2xl font-bold text-green-400">
                                        {targetServings} {targetServings === 1 ? 'Serving' : 'Servings'} Scaled
                                    </h2>
                                    {parsedIngredients.length > 0 && (
                                        <div className="flex flex-wrap gap-2">
                                            <button
                                                onClick={() => setCookingMode(!cookingMode)}
                                                className={`px-3 py-1.5 rounded text-sm transition-colors ${
                                                    cookingMode 
                                                        ? 'bg-gray-700 text-gray-300 hover:bg-gray-600' 
                                                        : 'bg-gray-700 text-gray-300 hover:bg-gray-600'
                                                }`}
                                            >
                                                {cookingMode ? 'Show Details' : 'Edit Mode'}
                                            </button>
                                            <button
                                                onClick={copyToClipboard}
                                                className="px-3 py-1.5 bg-green-600 hover:bg-green-700 rounded text-sm"
                                            >
                                                {copySuccess ? '✓ Copied!' : '📋 Copy'}
                                            </button>
                                        </div>
                                    )}
                                </div>

                                {parsedIngredients.length === 0 ? (
                                    <div className="text-gray-400 text-center py-12">
                                        Paste ingredients above to see scaled results
                                    </div>
                                ) : (
                                    <>
                                        <div className="space-y-3">
                                            {parsedIngredients.map((ingredient, idx) => {
                                                const scaled = scaleIngredient(ingredient, idx);
                                                const unitOptions = getUnitOptions(ingredient);
                                                const showWarning = isAmbiguous(ingredient);
                                                const isChecked = checkedIngredients[idx];
                                                
                                                return (
                                                    <div 
                                                        key={idx} 
                                                        className="group"
                                                    >
                                                        {/* Main ingredient line */}
                                                        <div className="flex items-start gap-3 py-2 border-b border-gray-700/50">
                                                            <button
                                                                onClick={() => toggleIngredientChecked(idx)}
                                                                className="flex-shrink-0 w-5 h-5 mt-0.5 opacity-0 group-hover:opacity-100 transition-opacity"
                                                            >
                                                                {isChecked ? (
                                                                    <div className="w-5 h-5 rounded bg-green-600/30 flex items-center justify-center text-green-400 text-xs">✓</div>
                                                                ) : (
                                                                    <div className="w-5 h-5 rounded border border-gray-600"></div>
                                                                )}
                                                            </button>
                                                            
                                                            <div className={`flex-1 min-w-0 ${isChecked ? 'opacity-40 line-through' : ''}`}>
                                                                {ingredient.type === 'seasoning' ? (
                                                                    <div className="text-base leading-relaxed">
                                                                        <span className="text-gray-300">{ingredient.ingredient}</span>
                                                                        <span className="text-gray-500 ml-2 italic">to taste</span>
                                                                    </div>
                                                                ) : (
                                                                    <div className="text-base leading-relaxed">
                                                                        <span className="text-green-400 font-medium">
                                                                            {formatCompoundMeasurement(scaled)}
                                                                        </span>
                                                                        <span className="text-gray-200 ml-2">
                                                                            {(() => {
                                                                                // DEBUG: Log ingredient name
                                                                                if (ingredient.ingredient.includes('salt') || ingredient.ingredient.includes('butter')) {
                                                                                    console.log('DEBUG ingredient name:', ingredient.ingredient);
                                                                                    console.log('DEBUG full ingredient object:', JSON.stringify(ingredient, null, 2));
                                                                                }
                                                                                return ingredient.ingredient;
                                                                            })()}
                                                                        </span>
                                                                        {/* Show scaled alternative if present */}
                                                                        {ingredient.alternative && (() => {
                                                                            const scaleFactor = (targetServings || 1) / (originalServings || 1);
                                                                            const scaledAlt = scaleAlternative(ingredient.alternative, scaleFactor);
                                                                            if (scaledAlt) {
                                                                                return (
                                                                                    <span className="text-gray-400 ml-2 text-sm">
                                                                                        (or {formatCompoundMeasurement(scaledAlt)} {ingredient.alternative.ingredient})
                                                                                    </span>
                                                                                );
                                                                            }
                                                                        })()}
                                                                        {/* Show conversion in parentheses */}
                                                                        {scaled.converted && scaled.originalScaledValue && (
                                                                            <span className="text-gray-500 ml-2 text-sm">
                                                                                ({formatNumber(scaled.originalScaledValue)} {pluralize(scaled.originalScaledValue, scaled.originalUnit === 'count' ? ingredient.ingredient.split(' ')[0] : scaled.originalUnit)})
                                                                            </span>
                                                                        )}
                                                                    </div>
                                                                )}
                                                                
                                                                {/* Edit mode controls - only visible when edit mode is on */}
                                                                {cookingMode && (
                                                                    <div className="mt-2 flex flex-wrap gap-2 items-center text-xs">
                                                                        {ingredient.isRange && ingredient.rangeOriginal && (
                                                                            <span className="text-yellow-500 bg-yellow-900/20 px-2 py-0.5 rounded">
                                                                                range: {ingredient.rangeOriginal} {ingredient.unit !== 'count' ? ingredient.unit : ''}
                                                                            </span>
                                                                        )}
                                                                        {unitOptions.length > 0 && (
                                                                            <select
                                                                                value={unitOverrides[idx] || 'auto'}
                                                                                onChange={(e) => setUnitOverride(idx, e.target.value === 'auto' ? null : e.target.value)}
                                                                                className="bg-gray-700 text-gray-300 px-2 py-0.5 rounded border border-gray-600 focus:border-green-400 focus:outline-none"
                                                                            >
                                                                                <option value="auto">auto</option>
                                                                                {unitOptions.map(unit => (
                                                                                    <option key={unit} value={unit}>{unit}</option>
                                                                                ))}
                                                                            </select>
                                                                        )}
                                                                        <span className="text-gray-600">
                                                                            originally {ingredient.quantity} {ingredient.unit}
                                                                        </span>
                                                                    </div>
                                                                )}
                                                                
                                                                {/* Warning - always visible if present */}
                                                                {showWarning && !cookingMode && (
                                                                    <div className="mt-1.5 text-xs text-orange-400/80">
                                                                        ⚠ {getAmbiguityWarning(ingredient)}
                                                                    </div>
                                                                )}
                                                                
                                                                {ingredient.notes && (
                                                                    <div className="mt-1 text-xs text-gray-500">
                                                                        {ingredient.notes}
                                                                    </div>
                                                                )}
                                                            </div>
                                                        </div>
                                                    </div>
                                                );
                                            })}
                                        </div>
                                        
                                        {unparsedLines.length > 0 && cookingMode && (
                                            <div className="mt-6 p-3 bg-red-900/20 border border-red-700/50 rounded text-sm">
                                                <div className="text-red-400 font-medium mb-1">Couldn't parse:</div>
                                                {unparsedLines.map((line, idx) => (
                                                    <div key={idx} className="text-red-300/80 text-xs">• {line}</div>
                                                ))}
                                            </div>
                                        )}
                                        
                                        {cookingMode && (
                                            <div className="mt-6 pt-4 border-t border-gray-700/50 text-xs text-gray-500">
                                                {parsedIngredients.length} ingredients • {((targetServings || 1) / (originalServings || 1)).toFixed(2)}x scale
                                            </div>
                                        )}
                                    </>
                                )}
                            </div>
                        </div>

                        <div className="mt-6 bg-gray-800 rounded-lg shadow-xl p-4 text-sm text-gray-400">
                            <strong className="text-green-400">Tips:</strong>
                            <ul className="mt-2 space-y-1 list-disc list-inside">
                                <li>Supports formats like: "2 cups flour", "1/2 tsp salt", "2 1/2 cups water", "250g sugar", "3 eggs"</li>
                                <li>Handles whole items: "2 potatoes", "1 onion", "4 chicken breasts"</li>
                                <li>Handles messy copy-paste - ignores extra text and instructions</li>
                                <li>Smart unit conversion: 96 tsp → 2 cups (or metric equivalent)</li>
                                <li><strong>Ranges:</strong> "1-2 cups" or "2-3 eggs" - choose how to handle them above (low/average/high). Scaled ranges shown in Edit Mode.</li>
                                <li>Mixed fractions: "2 1/2 cups" works perfectly</li>
                            </ul>
                        </div>
                        </>
                        )}
                    </div>
                </div>
            );
        }

        ReactDOM.render(<RecipeScaler />, document.getElementById('root'));
    </script>
</body>
</html>
